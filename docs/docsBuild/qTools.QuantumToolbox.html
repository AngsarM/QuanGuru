

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title>qTools.QuantumToolbox package &mdash; Quantum Simulations 1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="./" src="_static/documentation_options.js"></script>
        <script src="_static/jquery.js"></script>
        <script src="_static/underscore.js"></script>
        <script src="_static/doctools.js"></script>
        <script src="_static/language_data.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="_static/style.css" type="text/css" />
  <link rel="stylesheet" href="_static/custom.css" type="text/css" />
  <link rel="stylesheet" href="_static/gallery.css" type="text/css" />
  <link rel="stylesheet" href="_static/jupyter-sphinx.css" type="text/css" />
    <link rel="index" title="Index" href="genindex.html" />
    <link rel="search" title="Search" href="search.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #051988" >
          

          
            <a href="index.html" class="icon icon-home"> Quantum Simulations
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <p class="caption"><span class="caption-text">Contents:</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="states.html">States</a></li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="index.html">Quantum Simulations</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="index.html">Docs</a> &raquo;</li>
        
      <li>qTools.QuantumToolbox package</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="_sources/qTools.QuantumToolbox.rst" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="section" id="qtools-quantumtoolbox-package">
<h1>qTools.QuantumToolbox package<a class="headerlink" href="#qtools-quantumtoolbox-package" title="Permalink to this headline">¶</a></h1>
<div class="section" id="subpackages">
<h2>Subpackages<a class="headerlink" href="#subpackages" title="Permalink to this headline">¶</a></h2>
<div class="toctree-wrapper compound">
</div>
</div>
<div class="section" id="submodules">
<h2>Submodules<a class="headerlink" href="#submodules" title="Permalink to this headline">¶</a></h2>
</div>
<div class="section" id="module-qTools.QuantumToolbox.Hamiltonians">
<span id="qtools-quantumtoolbox-hamiltonians-module"></span><h2>qTools.QuantumToolbox.Hamiltonians module<a class="headerlink" href="#module-qTools.QuantumToolbox.Hamiltonians" title="Permalink to this headline">¶</a></h2>
<p>Module of functions to create some standard Hamiltonians.</p>
<div class="section" id="functions">
<h3>Functions<a class="headerlink" href="#functions" title="Permalink to this headline">¶</a></h3>
<p>:cavQubFreeHam : Creates Cavity + Qubit Hamiltonian for given frequencies and truncated cavity dimension
:RabiHam : Creates Rabi Hamiltonian for given frequencies, coupling strength, and truncated cavity dimension
:JCHam : Creates Jaynes-Cummings Hamiltonian for given frequencies, coupling strength, and truncated cavity dimension
:aJCHam : Creates anti-Jaynes-Cummings Hamiltonian for given frequencies, coupling strength, and truncated cavity dimension</p>
<dl class="function">
<dt id="qTools.QuantumToolbox.Hamiltonians.JCHam">
<code class="sig-name descname">JCHam</code><span class="sig-paren">(</span><em class="sig-param">cavFreq: float</em>, <em class="sig-param">qubFreq: float</em>, <em class="sig-param">g: float</em>, <em class="sig-param">cavDim: int</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/Hamiltonians.html#JCHam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.Hamiltonians.JCHam" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates Jaynes-Cummings Hamiltonian for given frequencies, coupling strength, and truncated cavity dimension</p>
<p>:param :
:type : param <cite>cavFreq</cite> : cavity frequency
:param :
:type : param <cite>qubFreq</cite> : qubit frequency
:param :
:type : param <cite>g</cite> : coupling strength
:param :
:type : param <cite>cavDim</cite> : (truncated) dimension for cavity</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Jaynes-Cummings Hamiltonian for given frequencies</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.Hamiltonians.RabiHam">
<code class="sig-name descname">RabiHam</code><span class="sig-paren">(</span><em class="sig-param">cavFreq: float</em>, <em class="sig-param">qubFreq: float</em>, <em class="sig-param">g: float</em>, <em class="sig-param">cavDim: int</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/Hamiltonians.html#RabiHam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.Hamiltonians.RabiHam" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates Rabi Hamiltonian for given frequencies, coupling strength, and truncated cavity dimension</p>
<p>:param :
:type : param <cite>cavFreq</cite> : cavity frequency
:param :
:type : param <cite>qubFreq</cite> : qubit frequency
:param :
:type : param <cite>g</cite> : coupling strength
:param :
:type : param <cite>cavDim</cite> : (truncated) dimension for cavity</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Rabi Hamiltonian for given frequencies</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.Hamiltonians.aJCHam">
<code class="sig-name descname">aJCHam</code><span class="sig-paren">(</span><em class="sig-param">cavFreq: float</em>, <em class="sig-param">qubFreq: float</em>, <em class="sig-param">g: float</em>, <em class="sig-param">cavDim: int</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/Hamiltonians.html#aJCHam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.Hamiltonians.aJCHam" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates anti-Jaynes-Cummings Hamiltonian for given frequencies, coupling strength, and truncated cavity dimension</p>
<p>:param :
:type : param <cite>cavFreq</cite> : cavity frequency
:param :
:type : param <cite>qubFreq</cite> : qubit frequency
:param :
:type : param <cite>g</cite> : coupling strength
:param :
:type : param <cite>cavDim</cite> : (truncated) dimension for cavity</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: anti-Jaynes-Cummings Hamiltonian for given frequencies</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.Hamiltonians.cavQubFreeHam">
<code class="sig-name descname">cavQubFreeHam</code><span class="sig-paren">(</span><em class="sig-param">cavFreq: float</em>, <em class="sig-param">qubFreq: float</em>, <em class="sig-param">cavDim: int</em><span class="sig-paren">)</span> &#x2192; Tuple[Matrix, Matrix]<a class="reference internal" href="_modules/qTools/QuantumToolbox/Hamiltonians.html#cavQubFreeHam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.Hamiltonians.cavQubFreeHam" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates Cavity + Qubit Hamiltonian for given frequencies and truncated cavity dimension</p>
<p>:param :
:type : param <cite>cavFreq</cite> : cavity frequency
:param :
:type : param <cite>qubFreq</cite> : qubit frequency
:param :
:type : param <cite>cavDim</cite> : (truncated) dimension for cavity</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Cavity + Qubit Hamiltonian for given frequencies</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

</div>
</div>
<div class="section" id="module-qTools.QuantumToolbox.customTypes">
<span id="qtools-quantumtoolbox-customtypes-module"></span><h2>qTools.QuantumToolbox.customTypes module<a class="headerlink" href="#module-qTools.QuantumToolbox.customTypes" title="Permalink to this headline">¶</a></h2>
<p>A module for custom types (Union etc) used in QuantumToolbox</p>
<div class="section" id="types">
<h3>Types<a class="headerlink" href="#types" title="Permalink to this headline">¶</a></h3>
<p>:Matrix : Type which is either spmatrix or nparray (created using TypeVar)
:intList : Type for a list of integers
:floatList : Type for a list of floats
:matrixList : Type for a list <cite>Matrix</cite> types
:supInp : Type from the union the types: int, <cite>intList</cite>, and a dict with int:float key:value combination
:ndOrListInt : Type from the union of ndarray and intList</p>
</div>
</div>
<div class="section" id="module-qTools.QuantumToolbox.evolution">
<span id="qtools-quantumtoolbox-evolution-module"></span><h2>qTools.QuantumToolbox.evolution module<a class="headerlink" href="#module-qTools.QuantumToolbox.evolution" title="Permalink to this headline">¶</a></h2>
<p>Module of functions to create Unitary operator and open-system super-operators.</p>
<dl class="method">
<dt>
<code class="sig-name descname">:Unitary : Creates Unitary time evolution operator for a given Hamiltonian and time step</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:Liouvillian : Creates Liouvillian super-operator for a given Hamiltonian, time step,</code></dt>
<dd><p>and a <cite>list</cite> of collapse operators (with correcponding <cite>list</cite> of decay rates)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:LiouvillianExp : Creates Liouvillian super-operator (and exponentiates) for a given Hamiltonian, time step,</code></dt>
<dd><p>and a <cite>list</cite> of collapse operators (with correcponding <cite>list</cite> of decay rates)</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:dissipator : Creates the Lindblad dissipator super-operator for a collapse operator</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:_preSO : Creates `pre` super-operator for an operator</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:_posSO : Creates `pos` super-operator for an operator</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:_preposSO : Creates `pre-pos` super-operator for an operator</code></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.evolution.Liouvillian">
<code class="sig-name descname">Liouvillian</code><span class="sig-paren">(</span><em class="sig-param">Hamiltonian: Optional[Matrix] = None</em>, <em class="sig-param">collapseOperators: list = []</em>, <em class="sig-param">decayRates: list = []</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/evolution.html#Liouvillian"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.evolution.Liouvillian" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates Liouvillian super-operator for a given Hamiltonian, time step,
and a <cite>list</cite> of collapse operators (with correcponding <cite>list</cite> of decay rates)</p>
<p>Keeps sparse/array as sparse/array.</p>
<p>:param :
:type : param <cite>Hamiltonian</cite> : Hamiltonian of the system
:param :
:type : param <cite>timeStep</cite> : time used in the exponentiation (default=1)
:param :
:type : param <cite>collapseOperators</cite> : <cite>list</cite> of collapse operator for Lindblad dissipator terms
:param :
:type : param <cite>decayRates</cite> : <cite>list</cite> of decay rates (if not given assumed to be 1)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Liouvillian super-operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.evolution.LiouvillianExp">
<code class="sig-name descname">LiouvillianExp</code><span class="sig-paren">(</span><em class="sig-param">Hamiltonian: Optional[Matrix] = None</em>, <em class="sig-param">timeStep: float = 1.0</em>, <em class="sig-param">collapseOperators: list = []</em>, <em class="sig-param">decayRates: list = []</em>, <em class="sig-param">exp: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/evolution.html#LiouvillianExp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.evolution.LiouvillianExp" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates Liovillian super-operator for a given Hamiltonian, time step,
and a <cite>list</cite> of collapse operators (with correcponding <cite>list</cite> of decay rates)</p>
<p>Keeps sparse/array as sparse/array.</p>
<p>:param :
:type : param <cite>Hamiltonian</cite> : Hamiltonian of the system
:param :
:type : param <cite>timeStep</cite> : time used in the exponentiation (default=1)
:param :
:type : param <cite>collapseOperators</cite> : <cite>list</cite> of collapse operator for Lindblad dissipator terms
:param :
:type : param <cite>decayRates</cite> : <cite>list</cite> of decay rates (if not given assumed to be 1)
:param :
:type : param <cite>exp</cite> : boolean to exponentiate the Liouvillian or not (=True by default)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: (exponentiated) Liouvillian super-operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.evolution.Unitary">
<code class="sig-name descname">Unitary</code><span class="sig-paren">(</span><em class="sig-param">Hamiltonian: Matrix</em>, <em class="sig-param">timeStep: float = 1.0</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/evolution.html#Unitary"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.evolution.Unitary" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates Unitary time evolution operator for a given Hamiltonian and time step</p>
<p>Keeps sparse/array as sparse/array.</p>
<p>:param :
:type : param <cite>Hamiltonian</cite> : Hamiltonian of the system
:param :
:type : param <cite>timeStep</cite> : time used in the exponentiation (default=1)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Unitary time evolution operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.evolution.dissipator">
<code class="sig-name descname">dissipator</code><span class="sig-paren">(</span><em class="sig-param">collapseOperator: Matrix</em>, <em class="sig-param">identity: Optional[Matrix] = None</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/evolution.html#dissipator"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.evolution.dissipator" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the Lindblad dissipator super-operator for a collapse operator</p>
<p>Keeps sparse/array as sparse/array.</p>
<p>:param :
:type : param <cite>collapseOperator</cite> : a collapse operator
:param :
:type : param <cite>identity</cite> : identity operator (exist for internal use and optimisation)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Lindblad dissipator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

</div>
<div class="section" id="module-qTools.QuantumToolbox.functions">
<span id="qtools-quantumtoolbox-functions-module"></span><h2>qTools.QuantumToolbox.functions module<a class="headerlink" href="#module-qTools.QuantumToolbox.functions" title="Permalink to this headline">¶</a></h2>
<p>Module of functions to calculate expectations, fidelities, entropy etc. from quantum states</p>
<p>The reason for having several methods for the same task is to improve performance
For example, an if statement can be avoided using <cite>expectationMat/expectationKet</cite> for
<cite>density matrices/ket states</cite>, or
<cite>expectationKetList/expectationMatList</cite> is suitable in <cite>multi-processing</cite> of list of time-series of states</p>
<dl class="method">
<dt>
<code class="sig-name descname">:expectation : Function to calculate the expectation value of an `operator` for a given `state`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:expectationMat : Calculates the expectation value of an `operator` for a given `density matrix`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:expectationKet : Calculates the expectation value of an `operator` for a given `ket`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:expectationKetList : Calculates the expectation value of an `operator` for a given list of `ket` states</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:expectationMatList : Calculates the expectation value of an `operator` for a given list of `density matrices`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:expectationColArr : Calculates the expectation values of an `operator` for a list/matrix of `ket (column) states`</code></dt>
<dd><p>by matrix multiplication</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:fidelity : Calculates `fidelity` between `two states`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:fidelityKet : Calculates `fidelity` between two `ket` states</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:fidelityPureMat : Calculates `fidelity` between two (pure) `density matrices`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:fidelityKetList : Calculates `fidelity` between `a ket state` and `list of ket states`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:fidelityKetLists : Created to be used in `multi-processing` calculations of two lists of kets states</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:entropy : Calculates the `entropy` of a given `density matrix`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:entropyKet : Calculates the `entropy` of a given `ket` state</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprKet : Calculates the inverse participation ratio (a delocalisation measure) of a `ket` in a given basis</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprKetList : Calculates the inverse participation ratio (a delocalisation measure) of a `list of ket` states in a given basis</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprKetNB : Calculates the inverse participation ratio (a delocalisation measure) of a ket</code></dt>
<dd><p>by assuming that the basis is of the free Hamiltonian</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprKetNBList : Calculates the inverse participation ratio (a delocalisation measure) of a list kets</code></dt>
<dd><p>by assuming that the basis is of the free Hamiltonian</p>
</dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprKetNBmat : Calculates the inverse participation ratio (a delocalisation measure) of `a matrix of ket states as the column`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:iprPureDenMat : Calculates the inverse participation ratio (a delocalisation measure) of a `density matrix` in a given `basis`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:sortedEigens : Calculates the `eigenvalues and eigenvectors` of a given Hamiltonian and `sorts` them</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:eigVecStatKet : Calculates components of a `ket` in a basis</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:eigVecStatKetList : Calculates components of a `list of ket states`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:eigVecStatKetNB : Calculates the components of a ket by assuming that the basis is of the free Hamiltonian</code></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.eigVecStatKet">
<code class="sig-name descname">eigVecStatKet</code><span class="sig-paren">(</span><em class="sig-param">basis: List[Matrix], ket: Matrix</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#eigVecStatKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.eigVecStatKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates components of a <cite>ket</cite> in a basis</p>
<p>Main use is in eigenvector statistics.</p>
<p>:param :
:type : param <cite>basis</cite> : a complete basis
:param :
:type : param <cite>ket</cite> : the ket state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of component values in the basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">components</span> <span class="o">=</span> <span class="n">eigVecStatKet</span><span class="p">(</span><span class="n">basis</span><span class="o">=</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">ket</span><span class="o">=</span><span class="n">ket</span><span class="p">)</span>
<span class="go">[0, 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.eigVecStatKetList">
<code class="sig-name descname">eigVecStatKetList</code><span class="sig-paren">(</span><em class="sig-param">basis: List[Matrix], kets: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[List[float]]<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#eigVecStatKetList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.eigVecStatKetList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates components of a <cite>list of ket states</cite>
Main use is in eigenvector statistics.</p>
<p>:param :
:type : param <cite>basis</cite> : a complete basis
:param :
:type : param <cite>kets</cite> : <cite>list</cite> of ket states</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of component values in the basis</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ketList</span> <span class="o">=</span> <span class="p">[</span><span class="n">ket0</span><span class="p">,</span> <span class="n">ket1</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">components</span> <span class="o">=</span> <span class="n">eigVecStatKetList</span><span class="p">(</span><span class="n">basis</span><span class="o">=</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">kets</span><span class="o">=</span><span class="n">ketList</span><span class="p">)</span>
<span class="go">[[1, 0], [0, 1]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.eigVecStatKetNB">
<code class="sig-name descname">eigVecStatKetNB</code><span class="sig-paren">(</span><em class="sig-param">ket: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#eigVecStatKetNB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.eigVecStatKetNB" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the components of a ket by assuming that the basis is of the free Hamiltonian</p>
<p>:param :
:type : param <cite>ket</cite>: a ket state or list of ket states</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p><strong>return</strong></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>list of components</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">components</span> <span class="o">=</span> <span class="n">eigVecStatKetNB</span><span class="p">(</span><span class="n">ket</span><span class="o">=</span><span class="n">ket</span><span class="p">)</span>
<span class="go">[0 1]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.entropy">
<code class="sig-name descname">entropy</code><span class="sig-paren">(</span><em class="sig-param">densMat: Matrix</em>, <em class="sig-param">base2: bool = False</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#entropy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.entropy" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the <cite>entropy</cite> of a given <cite>density matrix</cite></p>
<p>Input should be a density matrix by definition of entropy.
Uses exponential basis as default.</p>
<p>:param :
:type : param <cite>densMat</cite>: a density matrix
:param :
:type : param <cite>base2</cite>: option to calculate in base 2</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: the <cite>entropy</cite> of the given <cite>density matrix</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compositeStateKet</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">compositeState</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyKet</span> <span class="o">=</span> <span class="n">entropyKet</span><span class="p">(</span><span class="n">compositeStateKet</span><span class="p">)</span>
<span class="go">-0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compositeStateMat</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">compositeStateKet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyMat</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">compositeStateMat</span><span class="p">)</span>
<span class="go">-0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateFirstSystem</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">compositeStateKet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy1</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">stateFirstSystem</span><span class="p">)</span>
<span class="go">-0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateSecondSystem</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">compositeStateKet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy2</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">stateSecondSystem</span><span class="p">)</span>
<span class="go">-0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entangledKet</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="n">qStates</span><span class="o">.</span><span class="n">compositeState</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">+ qStates.compositeState(dimensions=[2, 2], excitations=[1,0], sparse=True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyKetEntangled</span> <span class="o">=</span> <span class="n">entropyKet</span><span class="p">(</span><span class="n">entangledKet</span><span class="p">)</span>
<span class="go">2.2204460492503126e-16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entangledMat</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">entangledKet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyMatEntangled</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">entangledMat</span><span class="p">)</span>
<span class="go">2.2204460492503126e-16</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateFirstSystemEntangled</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">entangledKet</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy1Entangled</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">stateFirstSystemEntangled</span><span class="p">)</span>
<span class="go">0.6931471805599454</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateSecondSystemEntangled</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">entangledMat</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropy2Entangled</span> <span class="o">=</span> <span class="n">entropy</span><span class="p">(</span><span class="n">stateSecondSystemEntangled</span><span class="p">)</span>
<span class="go">0.6931471805599454</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.entropyKet">
<code class="sig-name descname">entropyKet</code><span class="sig-paren">(</span><em class="sig-param">ket: Matrix</em>, <em class="sig-param">base2: bool = False</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#entropyKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.entropyKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the <cite>entropy</cite> of a given <cite>ket</cite> state</p>
<p>This function should not exist at all, ket is always a pure state.</p>
<p>Input should be a density matrix by definition of entropy.
Uses exponential basis as default.</p>
<p>:param :
:type : param <cite>ket</cite> : a ket state
:param :
:type : param <cite>base2</cite> : option to calculate in base 2</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: the <cite>entropy</cite> of the given <cite>density matrix</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">compositeStateKet</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">compositeState</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyKet</span> <span class="o">=</span> <span class="n">entropyKet</span><span class="p">(</span><span class="n">compositeStateKet</span><span class="p">)</span>
<span class="go">-0.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entangledKet</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="n">qStates</span><span class="o">.</span><span class="n">compositeState</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">+ qStates.compositeState(dimensions=[2, 2], excitations=[1,0], sparse=True))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">entropyKetEntangled</span> <span class="o">=</span> <span class="n">entropyKet</span><span class="p">(</span><span class="n">entangledKet</span><span class="p">)</span>
<span class="go">2.2204460492503126e-16</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectation">
<code class="sig-name descname">expectation</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix</em>, <em class="sig-param">state: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#expectation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectation" title="Permalink to this definition">¶</a></dt>
<dd><p>Function to calculate the expectation value of an <cite>operator</cite> for a given <cite>state</cite></p>
<p>State can either be a <cite>ket</cite> or <cite>density matrix</cite>.
Operator has to be the matrix (sparse or not), cannot pass a reference to operator function from the toolbox.
State and operator can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>operator</cite> : matrix of a Hermitian operator
:param :
:type : param <cite>state</cite> : a quantum state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: expectation value of the <cite>operator</cite> for the <cite>state</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectMat</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">denMat</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">denMat1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectationColArr">
<code class="sig-name descname">expectationColArr</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix</em>, <em class="sig-param">states: numpy.ndarray</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#expectationColArr"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectationColArr" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation values of an <cite>operator</cite> for a list/matrix of <cite>ket (column) states</cite> by matrix multiplication</p>
<p>The <cite>list</cite> here is effectively a matrix whose columns are <cite>ket</cite> states for which we want the expectation values.
For example, the eigenstates obtained from eigenvalue calculations of numpy or scipy are this form.
TODO introduced to be used with eigenvectors, needs to be tested for non-mutually orthogonal states.
So, it relies on states being orthonormal, if not there will be off-diagonal elements in the resultant matrix,
but still the diagonal elements are the expectation values, meaning it should work!</p>
<p>:param :
:type : param <cite>operator</cite> : matrix of a Hermitian operator
:param :
:type : param <cite>states</cite> : ket states as the columns in the input matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of expectation values of the <cite>operator</cite> for a matrix of <cite>ket</cite> states</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ham</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigVals</span><span class="p">,</span> <span class="n">eigVecs</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">ham</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sz</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sx</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmax</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectZ</span> <span class="o">=</span> <span class="n">expectationColArr</span><span class="p">(</span><span class="n">sz</span><span class="p">,</span> <span class="n">eigVecs</span><span class="p">)</span>
<span class="go">[ 1. -1.]</span>
<span class="go">&gt;&gt;&gt;&gt; expectX = expectationColArr(sx, eigVecs)</span>
<span class="go">[0. 0.]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectationKet">
<code class="sig-name descname">expectationKet</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix</em>, <em class="sig-param">ket: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#expectationKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectationKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value of an <cite>operator</cite> for a given <cite>ket</cite></p>
<p>Calculates the density matrix and calls the expectationMat.
Computationally the same as using (bra &#64; operator &#64; ket).
Works with both sparse and array.
Operator has to be the matrix (sparse or not), cannot pass a reference to operator function from the toolbox.</p>
<p>:param :
:type : param <cite>operator</cite> : matrix of a Hermitian operator
:param :
:type : param <cite>ket</cite> : ket state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: expectation value of the <cite>operator</cite> for the <cite>ket</cite> state</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectationKetList">
<code class="sig-name descname">expectationKetList</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix, kets: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#expectationKetList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectationKetList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value of an <cite>operator</cite> for a given list of <cite>ket</cite> states</p>
<p>Simply calls the <cite>expectationKet</cite> in a loop.
This function exist for easy use in multi-processing.</p>
<p>:param :
:type : param <cite>operator</cite>: matrix of a Hermitian operator
:param :
:type : param <cite>kets</cite> : list of ket states</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of expectation values of the <cite>operator</cite> for the list of <cite>ket</cite> states</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ketList</span> <span class="o">=</span> <span class="p">[</span><span class="n">ket0</span><span class="p">,</span> <span class="n">ket1</span><span class="p">,</span> <span class="n">ket2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKetList</span> <span class="o">=</span> <span class="n">expectationKetList</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">kets</span><span class="o">=</span><span class="n">ketList</span><span class="p">)</span>
<span class="go">[-1, 1, 0.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectationMat">
<code class="sig-name descname">expectationMat</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix</em>, <em class="sig-param">denMat: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#expectationMat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectationMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value of an <cite>operator</cite> for a given <cite>density matrix</cite></p>
<p>Works with both sparse and array.
Operator has to be the matrix (sparse or not), cannot pass a reference to operator function from the toolbox.
State and operator can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>operator</cite> : matrix of a Hermitian operator
:param :
:type : param <cite>denMat</cite> : density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: expectation value of the <cite>operator</cite> for the <cite>density matrix</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sigmaz</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectMat</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">denMat</span><span class="p">)</span>
<span class="go">-1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">denMat1</span><span class="p">)</span>
<span class="go">1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectKet</span> <span class="o">=</span> <span class="n">expectation</span><span class="p">(</span><span class="n">operator</span><span class="o">=</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.expectationMatList">
<code class="sig-name descname">expectationMatList</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix, denMats: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#expectationMatList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.expectationMatList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the expectation value of an <cite>operator</cite> for a given list of <cite>density matrices</cite></p>
<p>Simply calls the <cite>expectationMat</cite> in a loop.
This function exist for easy use in multi-processing.</p>
<p>:param :
:type : param <cite>operator</cite> : matrix of a Hermitian operator
:param :
:type : param <cite>denMats</cite> : list of density matrices</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of expectation values of the <cite>operator</cite> for the list of <cite>density matrices</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMatList</span> <span class="o">=</span> <span class="p">[</span><span class="n">denMat0</span><span class="p">,</span> <span class="n">denMat1</span><span class="p">,</span> <span class="n">denMat2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">expectMatList</span> <span class="o">=</span> <span class="n">expectationMatList</span><span class="p">(</span><span class="n">sigmaz</span><span class="p">,</span> <span class="n">denMats</span><span class="o">=</span><span class="n">denMatList</span><span class="p">)</span>
<span class="go">[-1, 1, 0.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.fidelity">
<code class="sig-name descname">fidelity</code><span class="sig-paren">(</span><em class="sig-param">state1: Matrix</em>, <em class="sig-param">state2: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#fidelity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.fidelity" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <cite>fidelity</cite> between <cite>two states</cite></p>
<p>States can either be a <cite>ket</cite> or <cite>density matrix</cite>,
and they can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>state1</cite>: <cite>ket</cite> state or <cite>density matrix</cite>
:param :
:type : param <cite>state2</cite> : <cite>ket</cite> state or <cite>density matrix</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>fidelity</cite> between any <cite>two states</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet01</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket1</span><span class="p">)</span>
<span class="go">0.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet02</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet12</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket1</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat01</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat02</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat12</span> <span class="o">=</span> <span class="n">fidelity</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat1</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.fidelityKet">
<code class="sig-name descname">fidelityKet</code><span class="sig-paren">(</span><em class="sig-param">ket1: Matrix</em>, <em class="sig-param">ket2: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#fidelityKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.fidelityKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <cite>fidelity</cite> between two <cite>ket</cite> states</p>
<p>States can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>ket1</cite> : ket state
:param :
:type : param <cite>ket2</cite> : ket state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>fidelity</cite> between two <cite>ket states</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet01</span> <span class="o">=</span> <span class="n">fidelityKet</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket1</span><span class="p">)</span>
<span class="go">0.</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet02</span> <span class="o">=</span> <span class="n">fidelityKet</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityKet12</span> <span class="o">=</span> <span class="n">fidelityKet</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">ket1</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">ket2</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.fidelityKetList">
<code class="sig-name descname">fidelityKetList</code><span class="sig-paren">(</span><em class="sig-param">ket1: Matrix, ketList: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#fidelityKetList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.fidelityKetList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <cite>fidelity</cite> between <cite>a ket state</cite> and <cite>list of ket states</cite></p>
<p>States can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>ket1</cite> : ket state
:param :
:type : param <cite>ketList</cite> : <cite>list</cite> of ket states</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>list</cite> of fidelities between <cite>a ket state</cite> and <cite>list of ket states</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ketList</span> <span class="o">=</span> <span class="p">[</span><span class="n">ket0</span><span class="p">,</span> <span class="n">ket1</span><span class="p">,</span> <span class="n">ket2</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityList</span> <span class="o">=</span> <span class="n">fidelityKetList</span><span class="p">(</span><span class="n">ket0</span><span class="p">,</span> <span class="n">ketList</span><span class="p">)</span>
<span class="go">[1, 0, 0.5000000000000001]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.fidelityKetLists">
<code class="sig-name descname">fidelityKetLists</code><span class="sig-paren">(</span><em class="sig-param">zippedStatesList: Any</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#fidelityKetLists"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.fidelityKetLists" title="Permalink to this definition">¶</a></dt>
<dd><p>Created to be used in <cite>multi-processing</cite> calculations of two lists of kets states</p>
<p>FIXME too specific, requires zipping</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.fidelityPureMat">
<code class="sig-name descname">fidelityPureMat</code><span class="sig-paren">(</span><em class="sig-param">denMat1: Matrix</em>, <em class="sig-param">denMat2: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#fidelityPureMat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.fidelityPureMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates <cite>fidelity</cite> between two (pure) <cite>density matrices</cite></p>
<p>States can both be sparse or array or any combination of the two.</p>
<p>:param :
:type : param <cite>denMat1</cite> : (pure) density matrix
:param :
:type : param <cite>denMat2</cite> : (pure) density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>fidelity</cite> between two (pure) <cite>density matrices</cite></p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ket2</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.5</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat01</span> <span class="o">=</span> <span class="n">fidelityPureMat</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat1</span><span class="p">)</span>
<span class="go">0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat02</span> <span class="o">=</span> <span class="n">fidelityPureMat</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat0</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0.5</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">fidelityMat12</span> <span class="o">=</span> <span class="n">fidelityPureMat</span><span class="p">(</span><span class="n">state1</span><span class="o">=</span><span class="n">denMat1</span><span class="p">,</span> <span class="n">state2</span><span class="o">=</span><span class="n">denMat2</span><span class="p">)</span>
<span class="go">0.5</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprKet">
<code class="sig-name descname">iprKet</code><span class="sig-paren">(</span><em class="sig-param">basis: List[Matrix], ket: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#iprKet"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprKet" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of a <cite>ket</cite> in a given basis</p>
<p>:param :
:type : param <cite>ket</cite> : a ket state
:param :
:type : param <cite>basis</cite> : a complete basis</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: inverse participation ratio</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr0</span> <span class="o">=</span> <span class="n">iprKet</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">state0</span><span class="p">)</span>
<span class="go">1.1245136186770428</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr1</span> <span class="o">=</span> <span class="n">iprKet</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">state1</span><span class="p">)</span>
<span class="go">2.000000000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr2</span> <span class="o">=</span> <span class="n">iprKet</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">state2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprKetList">
<code class="sig-name descname">iprKetList</code><span class="sig-paren">(</span><em class="sig-param">basis: List[Matrix], kets: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#iprKetList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprKetList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of a <cite>list of ket</cite> states in a given basis</p>
<p>Simply calls iprKet in a loop.</p>
<p>:param :
:type : param <cite>kets</cite> : a <cite>list</cite> of ket states
:param :
:type : param <cite>basis</cite> : a complete basis</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: a <cite>list</cite> of inverse participation ratios for the given list of ket states</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state3</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateList</span> <span class="o">=</span> <span class="p">[</span><span class="n">state0</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">,</span> <span class="n">state3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iprList</span> <span class="o">=</span> <span class="n">iprKetList</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">stateList</span><span class="p">)</span>
<span class="go">[1.1245136186770428, 2.000000000000001, 1.0, 1.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprKetNB">
<code class="sig-name descname">iprKetNB</code><span class="sig-paren">(</span><em class="sig-param">ket: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#iprKetNB"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprKetNB" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of a ket
by assuming that the basis is of the free Hamiltonian</p>
<p>:param :
:type : param <cite>ket</cite> : a ket state</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: inverse participation ratio</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr0</span> <span class="o">=</span> <span class="n">iprKetNB</span><span class="p">(</span><span class="n">state0</span><span class="p">)</span>
<span class="go">1.1245136186770428</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr1</span> <span class="o">=</span> <span class="n">iprKetNB</span><span class="p">(</span><span class="n">state1</span><span class="p">)</span>
<span class="go">2.000000000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr2</span> <span class="o">=</span> <span class="n">iprKetNB</span><span class="p">(</span><span class="n">state2</span><span class="p">)</span>
<span class="go">1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state3</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr3</span> <span class="o">=</span> <span class="n">iprKetNB</span><span class="p">(</span><span class="n">state3</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprKetNBList">
<code class="sig-name descname">iprKetNBList</code><span class="sig-paren">(</span><em class="sig-param">kets: List[Matrix]</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#iprKetNBList"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprKetNBList" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of a list kets
by assuming that the basis is of the free Hamiltonian</p>
<p>Simply calls iprKetNB in a loop.</p>
<p>:param :
:type : param kets: a <cite>list</cite> of ket states</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: a <cite>list</cite> of inverse participation ratios</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state3</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">stateList</span> <span class="o">=</span> <span class="p">[</span><span class="n">state0</span><span class="p">,</span> <span class="n">state1</span><span class="p">,</span> <span class="n">state2</span><span class="p">,</span> <span class="n">state3</span><span class="p">]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iprList</span> <span class="o">=</span> <span class="n">iprKetNBList</span><span class="p">(</span><span class="n">stateList</span><span class="p">)</span>
<span class="go">[1.1245136186770428, 2.000000000000001, 1.0, 1.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprKetNBmat">
<code class="sig-name descname">iprKetNBmat</code><span class="sig-paren">(</span><em class="sig-param">kets: numpy.ndarray</em><span class="sig-paren">)</span> &#x2192; List[float]<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#iprKetNBmat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprKetNBmat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of <cite>a matrix of ket states as the column</cite></p>
<p>For example the eigenstates obtained from eigenvalue calculations of numpy or scipy are this form.
TODO use if you know what you are doing.
This assumes the basis is of the free Hamiltonian.</p>
<p>:param :
:type : param ket: a density matrix</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: a <cite>list</cite> of inverse participation ratios</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ham</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">sigmaz</span><span class="p">()</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigValsHam</span><span class="p">,</span> <span class="n">eigVecsHams</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">ham</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iprHam</span> <span class="o">=</span> <span class="n">iprKetNBmat</span><span class="p">(</span><span class="n">eigVecsHams</span><span class="p">)</span>
<span class="go">[1.0, 1.0]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">unitary</span> <span class="o">=</span> <span class="n">sp</span><span class="o">.</span><span class="n">sparse</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">expm</span><span class="p">(</span><span class="n">ham</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigValsUni</span><span class="p">,</span> <span class="n">eigVecsUni</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">linalg</span><span class="o">.</span><span class="n">eig</span><span class="p">(</span><span class="n">unitary</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">iprUni</span> <span class="o">=</span> <span class="n">iprKetNBmat</span><span class="p">(</span><span class="n">eigVecsUni</span><span class="p">)</span>
<span class="go">[1.0, 1.0]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.iprPureDenMat">
<code class="sig-name descname">iprPureDenMat</code><span class="sig-paren">(</span><em class="sig-param">basis: List[Matrix], denMat: Matrix</em><span class="sig-paren">)</span> &#x2192; float<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#iprPureDenMat"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.iprPureDenMat" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the inverse participation ratio (a delocalisation measure) of a <cite>density matrix</cite> in a given <cite>basis</cite></p>
<p>:param :
:type : param <cite>denMat</cite> : a density matrix
:param :
:type : param <cite>basis</cite> : a complete basis</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: inverse participation ratio</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">completeBasis</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasisMat</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.2</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.8</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">state0</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr0</span> <span class="o">=</span> <span class="n">iprPureDenMat</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">denMat0</span><span class="p">)</span>
<span class="go">1.1245136186770428</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">)</span> <span class="o">+</span> <span class="mf">0.5</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">))</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">state1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr1</span> <span class="o">=</span> <span class="n">iprPureDenMat</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">denMat1</span><span class="p">)</span>
<span class="go">2.000000000000001</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">state2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">denMat2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">state2</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ipr2</span> <span class="o">=</span> <span class="n">iprPureDenMat</span><span class="p">(</span><span class="n">completeBasis</span><span class="p">,</span> <span class="n">denMat2</span><span class="p">)</span>
<span class="go">1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.functions.sortedEigens">
<code class="sig-name descname">sortedEigens</code><span class="sig-paren">(</span><em class="sig-param">Ham: Matrix</em><span class="sig-paren">)</span> &#x2192; Tuple[List[float], List[numpy.ndarray]]<a class="reference internal" href="_modules/qTools/QuantumToolbox/functions.html#sortedEigens"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.functions.sortedEigens" title="Permalink to this definition">¶</a></dt>
<dd><p>Calculates the <cite>eigenvalues and eigenvectors</cite> of a given Hamiltonian and <cite>sorts</cite> them</p>
<p>:param :
:type : param <cite>Ham</cite> : the Hamiltonian</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>sorted</cite> eigenvalues and eigenvectors</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.operators</span> <span class="k">as</span> <span class="nn">qOperators</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ham</span> <span class="o">=</span> <span class="n">qOperators</span><span class="o">.</span><span class="n">Jx</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">6</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">eigVals</span><span class="p">,</span> <span class="n">eigVecs</span> <span class="o">=</span> <span class="n">sortedEigens</span><span class="p">(</span><span class="n">ham</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eigVals</span><span class="p">)</span>
<span class="go">[-2.5+0.j -1.5+0.j -0.5+0.j  0.5+0.j  1.5+0.j  2.5+0.j]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="nb">print</span><span class="p">(</span><span class="n">eigVecs</span><span class="p">)</span>
<span class="go">[[ 0.1767767   0.39528471  0.55901699  0.55901699 -0.39528471 -0.1767767 ]</span>
<span class="go">[-0.39528471 -0.53033009 -0.25        0.25       -0.53033009 -0.39528471]</span>
<span class="go">[ 0.55901699  0.25       -0.35355339 -0.35355339 -0.25       -0.55901699]</span>
<span class="go">[-0.55901699  0.25        0.35355339 -0.35355339  0.25       -0.55901699]</span>
<span class="go">[ 0.39528471 -0.53033009  0.25        0.25        0.53033009 -0.39528471]</span>
<span class="go">[-0.1767767   0.39528471 -0.55901699  0.55901699  0.39528471 -0.1767767 ]]</span>
</pre></div>
</div>
</dd></dl>

</div>
<div class="section" id="module-qTools.QuantumToolbox.operations">
<span id="qtools-quantumtoolbox-operations-module"></span><h2>qTools.QuantumToolbox.operations module<a class="headerlink" href="#module-qTools.QuantumToolbox.operations" title="Permalink to this headline">¶</a></h2>
<p>Module of functions to create quantum operations (such as rotations).</p>
<dl class="method">
<dt>
<code class="sig-name descname">:xRotation : Creates the operator for Qubit `X rotation`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:yRotation : Creates the operator for Qubit `Y rotation`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:zRotation : Creates the operator for Qubit `Z rotation`</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:qubRotation : Creates the operator for Qubit rotation around given X/Y/Z</code></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operations.qubRotation">
<code class="sig-name descname">qubRotation</code><span class="sig-paren">(</span><em class="sig-param">xyz: str</em>, <em class="sig-param">angle: float</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operations.html#qubRotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operations.qubRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the operator for Qubit rotation around given X/Y/Z</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>xyz</cite> : string for rotation direction
:param :
:type : param <cite>angle</cite> : angle of rotation around <cite>x</cite>
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Qubit X/Y/Z rotation operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operations.xRotation">
<code class="sig-name descname">xRotation</code><span class="sig-paren">(</span><em class="sig-param">angle: float</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operations.html#xRotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operations.xRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the operator for Qubit <cite>X rotation</cite></p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>angle</cite> : angle of rotation around <cite>X</cite>
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Qubit X rotation operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operations.yRotation">
<code class="sig-name descname">yRotation</code><span class="sig-paren">(</span><em class="sig-param">angle: float</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operations.html#yRotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operations.yRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the operator for Qubit <cite>Y rotation</cite></p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>angle</cite> : angle of rotation around <cite>Y</cite>
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Qubit Y rotation operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operations.zRotation">
<code class="sig-name descname">zRotation</code><span class="sig-paren">(</span><em class="sig-param">angle: float</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operations.html#zRotation"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operations.zRotation" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the operator for Qubit <cite>Z rotation</cite></p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>angle</cite> : angle of rotation around <cite>Z</cite>
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Qubit Z rotation operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<p># TODO Create some examples both in here and the demo script</p>
</dd></dl>

</div>
<div class="section" id="module-qTools.QuantumToolbox.operators">
<span id="qtools-quantumtoolbox-operators-module"></span><h2>qTools.QuantumToolbox.operators module<a class="headerlink" href="#module-qTools.QuantumToolbox.operators" title="Permalink to this headline">¶</a></h2>
<p>Module of functions to create and/or manipulate quantum operators</p>
<div class="section" id="id1">
<h3>Functions<a class="headerlink" href="#id1" title="Permalink to this headline">¶</a></h3>
<blockquote>
<div><p>number : Creates the (bosonic) number (<img class="math" src="_images/math/2bb3984b414b729f6541f5db3ae9a86ce0c219a6.png" alt="\hat{n}"/>) operator
destroy : Creates the bosonic <cite>annihilation</cite> (<img class="math" src="_images/math/1b1a2b99575ee3eedd6e311fa15461e9c49012cb.png" alt="\hat{a}"/>) operator
create : Creates the bosonic <cite>creation</cite> (<img class="math" src="_images/math/2f9d9efe16954af247b44db0481257c56d42ceb7.png" alt="\hat{a}^{\dagger}"/>) operator</p>
<p>identity : Creates the identity operator</p>
<p>sigmaz : Creates the <cite>Pauli</cite> sigma z operator
sigmay : Creates the <cite>Pauli</cite> sigma y operator
sigmax : Creates the <cite>Pauli</cite> sigma x operator
sigmap : Creates the <cite>Pauli</cite> sigma + operator, i.e. 2D Fermionic creation operator
sigmam : Creates the <cite>Pauli</cite> sigma - operator, i.e. 2D Fermionic destruction operator</p>
<p>Jz : Creates the angular momentum (spin) <cite>Z</cite> operator for a given spin quantum number j
Jp : Creates the angular momentum (spin) <cite>creation</cite> operator for a given spin quantum number j
Jm : Creates the angular momentum (spin) <cite>destruction</cite> operator for a given spin quantum number j
Jx : Creates the angular momentum (spin) <cite>X</cite> operator for a given spin quantum number j
Jy : Creates the angular momentum (spin) <cite>Y</cite> operator for a given spin quantum number j
Js : Creates the total angular momentum (spin) operator for a given spin quantum number j</p>
<p>operatorPow : Creates a quantum operator for given function reference <cite>op</cite> and raises to a <cite>power</cite></p>
<p>paritySUM : Creates the parity operator by explicitly placing alternating +/- into a matrix
partiyEXP : Creates the parity operator by exponentiation a given Hamiltonian</p>
<p>basis : Creates a <cite>ket</cite> state</p>
<p>displacement : Creates the displacement operator for a given displacement parameter alpha
squeeze : Creates the squeezing operator for a given squeezing parameter alpha</p>
<p>compositeOp : Creates a composite operator from a sub-system <cite>operator</cite>,
i.e. tensor product with identities of dimensions dimB &amp; dimA</p>
</div></blockquote>
<dl class="function">
<dt id="qTools.QuantumToolbox.operators.Jm">
<code class="sig-name descname">Jm</code><span class="sig-paren">(</span><em class="sig-param">j: float</em>, <em class="sig-param">sparse: bool = True</em>, <em class="sig-param">isDim: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#Jm"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.Jm" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the angular momentum (spin) <cite>destruction</cite> operator for a given spin quantum number j</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>j</cite> : integer or half-integer spin quantum number, or the dimension (then spin quantum number = (d-1)/2)
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)
:param :
:type : param isDim: boolean for whether j is spin quantum number of dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Angular momentum (spin) destruction operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jm0</span> <span class="o">=</span> <span class="n">Jm</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.         0.         0.         0.         0.        ]</span>
<span class="go">[2.         0.         0.         0.         0.        ]</span>
<span class="go">[0.         2.44948974 0.         0.         0.        ]</span>
<span class="go">[0.         0.         2.44948974 0.         0.        ]</span>
<span class="go">[0.         0.         0.         2.         0.        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jm0</span> <span class="o">=</span> <span class="n">Jm</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, 0)      2.0</span>
<span class="go">(2, 1)      2.449489742783178</span>
<span class="go">(3, 2)      2.449489742783178</span>
<span class="go">(4, 3)      2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jm1</span> <span class="o">=</span> <span class="n">Jm</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.         0.         0.         0.         0.        ]</span>
<span class="go">[2.         0.         0.         0.         0.        ]</span>
<span class="go">[0.         2.44948974 0.         0.         0.        ]</span>
<span class="go">[0.         0.         2.44948974 0.         0.        ]</span>
<span class="go">[0.         0.         0.         2.         0.        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jm1</span> <span class="o">=</span> <span class="n">Jm</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 0)      2.0</span>
<span class="go">(2, 1)      2.449489742783178</span>
<span class="go">(3, 2)      2.449489742783178</span>
<span class="go">(4, 3)      2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.Jp">
<code class="sig-name descname">Jp</code><span class="sig-paren">(</span><em class="sig-param">j: float</em>, <em class="sig-param">sparse: bool = True</em>, <em class="sig-param">isDim: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#Jp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.Jp" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the angular momentum (spin) <cite>creation</cite> operator for a given spin quantum number j</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>j</cite> : integer or half-integer spin quantum number, or the dimension (then spin quantum number = (d-1)/2)
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)
:param :
:type : param isDim: boolean for whether j is spin quantum number of dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Angular momentum (spin) creation operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jp0</span> <span class="o">=</span> <span class="n">Jp</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.         2.         0.         0.         0.        ]</span>
<span class="go">[0.         0.         2.44948974 0.         0.        ]</span>
<span class="go">[0.         0.         0.         2.44948974 0.        ]</span>
<span class="go">[0.         0.         0.         0.         2.        ]</span>
<span class="go">[0.         0.         0.         0.         0.        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jp0</span> <span class="o">=</span> <span class="n">Jp</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(0, 1)      2.0</span>
<span class="go">(1, 2)      2.449489742783178</span>
<span class="go">(2, 3)      2.449489742783178</span>
<span class="go">(3, 4)      2.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jp1</span> <span class="o">=</span> <span class="n">Jp</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.         2.         0.         0.         0.        ]</span>
<span class="go">[0.         0.         2.44948974 0.         0.        ]</span>
<span class="go">[0.         0.         0.         2.44948974 0.        ]</span>
<span class="go">[0.         0.         0.         0.         2.        ]</span>
<span class="go">[0.         0.         0.         0.         0.        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jp1</span> <span class="o">=</span> <span class="n">Jp</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(0, 1)      2.0</span>
<span class="go">(1, 2)      2.449489742783178</span>
<span class="go">(2, 3)      2.449489742783178</span>
<span class="go">(3, 4)      2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.Js">
<code class="sig-name descname">Js</code><span class="sig-paren">(</span><em class="sig-param">j: float</em>, <em class="sig-param">sparse: bool = True</em>, <em class="sig-param">isDim: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#Js"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.Js" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the total angular momentum (spin) operator for a given spin quantum number j</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>j</cite> : integer or half-integer spin quantum number, or the dimension (then spin quantum number = (d-1)/2)
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)
:param :
:type : param isDim: boolean for whether j is spin quantum number of dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Total angular momentum (spin) operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">js0</span> <span class="o">=</span> <span class="n">Js</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[6.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go">[0.+0.j 6.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go">[0.+0.j 0.+0.j 6.+0.j 0.+0.j 0.+0.j]</span>
<span class="go">[0.+0.j 0.+0.j 0.+0.j 6.+0.j 0.+0.j]</span>
<span class="go">[0.+0.j 0.+0.j 0.+0.j 0.+0.j 6.+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">js0</span> <span class="o">=</span> <span class="n">Js</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(0, 0)      (6+0j)</span>
<span class="go">(1, 1)      (6+0j)</span>
<span class="go">(2, 2)      (5.999999999999999+0j)</span>
<span class="go">(3, 3)      (6+0j)</span>
<span class="go">(4, 4)      (6+0j)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">js1</span> <span class="o">=</span> <span class="n">Js</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[6.+0.j 0.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go">[0.+0.j 6.+0.j 0.+0.j 0.+0.j 0.+0.j]</span>
<span class="go">[0.+0.j 0.+0.j 6.+0.j 0.+0.j 0.+0.j]</span>
<span class="go">[0.+0.j 0.+0.j 0.+0.j 6.+0.j 0.+0.j]</span>
<span class="go">[0.+0.j 0.+0.j 0.+0.j 0.+0.j 6.+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">js1</span> <span class="o">=</span> <span class="n">Js</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(0, 0)      (6+0j)</span>
<span class="go">(1, 1)      (6+0j)</span>
<span class="go">(2, 2)      (5.999999999999999+0j)</span>
<span class="go">(3, 3)      (6+0j)</span>
<span class="go">(4, 4)      (6+0j)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.Jx">
<code class="sig-name descname">Jx</code><span class="sig-paren">(</span><em class="sig-param">j: float</em>, <em class="sig-param">sparse: bool = True</em>, <em class="sig-param">isDim: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#Jx"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.Jx" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the angular momentum (spin) <cite>X</cite> operator for a given spin quantum number j</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>j</cite> : integer or half-integer spin quantum number, or the dimension (then spin quantum number = (d-1)/2)
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)
:param :
:type : param isDim: boolean for whether j is spin quantum number of dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Angular momentum (spin) X operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jx0</span> <span class="o">=</span> <span class="n">Jx</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.         1.         0.         0.         0.        ]</span>
<span class="go">[1.         0.         1.22474487 0.         0.        ]</span>
<span class="go">[0.         1.22474487 0.         1.22474487 0.        ]</span>
<span class="go">[0.         0.         1.22474487 0.         1.        ]</span>
<span class="go">[0.         0.         0.         1.         0.        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jx0</span> <span class="o">=</span> <span class="n">Jx</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, 0)      1.0</span>
<span class="go">(0, 1)      1.0</span>
<span class="go">(2, 1)      1.224744871391589</span>
<span class="go">(1, 2)      1.224744871391589</span>
<span class="go">(3, 2)      1.224744871391589</span>
<span class="go">(2, 3)      1.224744871391589</span>
<span class="go">(4, 3)      1.0</span>
<span class="go">(3, 4)      1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jx1</span> <span class="o">=</span> <span class="n">Jx</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.         1.         0.         0.         0.        ]</span>
<span class="go">[1.         0.         1.22474487 0.         0.        ]</span>
<span class="go">[0.         1.22474487 0.         1.22474487 0.        ]</span>
<span class="go">[0.         0.         1.22474487 0.         1.        ]</span>
<span class="go">[0.         0.         0.         1.         0.        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jx1</span> <span class="o">=</span> <span class="n">Jx</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 0)      1.0</span>
<span class="go">(0, 1)      1.0</span>
<span class="go">(2, 1)      1.224744871391589</span>
<span class="go">(1, 2)      1.224744871391589</span>
<span class="go">(3, 2)      1.224744871391589</span>
<span class="go">(2, 3)      1.224744871391589</span>
<span class="go">(4, 3)      1.0</span>
<span class="go">(3, 4)      1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.Jy">
<code class="sig-name descname">Jy</code><span class="sig-paren">(</span><em class="sig-param">j: float</em>, <em class="sig-param">sparse: bool = True</em>, <em class="sig-param">isDim: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#Jy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.Jy" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the angular momentum (spin) <cite>Y</cite> operator for a given spin quantum number j</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>j</cite> : integer or half-integer spin quantum number, or the dimension (then spin quantum number = (d-1)/2)
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)
:param :
:type : param isDim: boolean for whether j is spin quantum number of dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Angular momentum (spin) Y operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jy0</span> <span class="o">=</span> <span class="n">Jy</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.+0.j         0.-1.j         0.+0.j         0.+0.j                0.+0.j        ]</span>
<span class="go">[0.+1.j         0.+0.j         0.-1.22474487j 0.+0.j                0.+0.j        ]</span>
<span class="go">[0.+0.j         0.+1.22474487j 0.+0.j         0.-1.22474487j        0.+0.j        ]</span>
<span class="go">[0.+0.j         0.+0.j         0.+1.22474487j 0.+0.j                0.-1.j        ]</span>
<span class="go">[0.+0.j         0.+0.j         0.+0.j         0.+1.j                0.+0.j        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jy0</span> <span class="o">=</span> <span class="n">Jy</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(1, 0)      1j</span>
<span class="go">(0, 1)      -1j</span>
<span class="go">(2, 1)      1.224744871391589j</span>
<span class="go">(1, 2)      -1.224744871391589j</span>
<span class="go">(3, 2)      1.224744871391589j</span>
<span class="go">(2, 3)      -1.224744871391589j</span>
<span class="go">(4, 3)      1j</span>
<span class="go">(3, 4)      -1j</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jy1</span> <span class="o">=</span> <span class="n">Jy</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.+0.j         0.-1.j         0.+0.j         0.+0.j                0.+0.j        ]</span>
<span class="go">[0.+1.j         0.+0.j         0.-1.22474487j 0.+0.j                0.+0.j        ]</span>
<span class="go">[0.+0.j         0.+1.22474487j 0.+0.j         0.-1.22474487j        0.+0.j        ]</span>
<span class="go">[0.+0.j         0.+0.j         0.+1.22474487j 0.+0.j                0.-1.j        ]</span>
<span class="go">[0.+0.j         0.+0.j         0.+0.j         0.+1.j                0.+0.j        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jy1</span> <span class="o">=</span> <span class="n">Jy</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(1, 0)      1j</span>
<span class="go">(0, 1)      -1j</span>
<span class="go">(2, 1)      1.224744871391589j</span>
<span class="go">(1, 2)      -1.224744871391589j</span>
<span class="go">(3, 2)      1.224744871391589j</span>
<span class="go">(2, 3)      -1.224744871391589j</span>
<span class="go">(4, 3)      1j</span>
<span class="go">(3, 4)      -1j</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.Jz">
<code class="sig-name descname">Jz</code><span class="sig-paren">(</span><em class="sig-param">j: float</em>, <em class="sig-param">sparse: bool = True</em>, <em class="sig-param">isDim: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#Jz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.Jz" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the angular momentum (spin) <cite>Z</cite> operator for a given spin quantum number j</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>j</cite> : integer or half-integer spin quantum number, or the dimension (then spin quantum number = (d-1)/2)
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)
:param :
:type : param isDim: boolean for whether j is spin quantum number of dimension</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Angular momentum (spin) Z operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">jz0</span> <span class="o">=</span> <span class="n">Jz</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[ 2  0  0  0  0]</span>
<span class="go">[ 0  1  0  0  0]</span>
<span class="go">[ 0  0  0  0  0]</span>
<span class="go">[ 0  0  0 -1  0]</span>
<span class="go">[ 0  0  0  0 -2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jz0</span> <span class="o">=</span> <span class="n">Jz</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">(0, 0)      2</span>
<span class="go">(1, 1)      1</span>
<span class="go">(2, 2)      0</span>
<span class="go">(3, 3)      -1</span>
<span class="go">(4, 4)      -2</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jz1</span> <span class="o">=</span> <span class="n">Jz</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[ 2.  0.  0.  0.  0.]</span>
<span class="go">[ 0.  1.  0.  0.  0.]</span>
<span class="go">[ 0.  0.  0.  0.  0.]</span>
<span class="go">[ 0.  0.  0. -1.  0.]</span>
<span class="go">[ 0.  0.  0.  0. -2.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">jz1</span> <span class="o">=</span> <span class="n">Jz</span><span class="p">(</span><span class="n">j</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">isDim</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="go">(0, 0)      2.0</span>
<span class="go">(1, 1)      1.0</span>
<span class="go">(2, 2)      0.0</span>
<span class="go">(3, 3)      -1.0</span>
<span class="go">(4, 4)      -2.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.basis">
<code class="sig-name descname">basis</code><span class="sig-paren">(</span><em class="sig-param">dimension: int</em>, <em class="sig-param">state: int</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#basis"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.basis" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a <cite>ket</cite> state</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>dimension</cite> : dimension of Hilbert space
:param :
:type : param <cite>state</cite> : index number for the populated state
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return : <cite>ket</cite> state</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">)</span>
<span class="go">(0, 0)      1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[1]</span>
<span class="go">[0]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.compositeOp">
<code class="sig-name descname">compositeOp</code><span class="sig-paren">(</span><em class="sig-param">operator: Matrix</em>, <em class="sig-param">dimB: int</em>, <em class="sig-param">dimA: int</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#compositeOp"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.compositeOp" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a composite operator from a sub-system <cite>operator</cite>, i.e. tensor product with identities of dimensions dimB &amp; dimA</p>
<p>:param :
:type : param <cite>operator</cite> : operator of a sub-system
:param :
:type : param <cite>dimB</cite> : (total) dimension of the systems that appear <cite>before</cite> in the tensor product order
:param :
:type : param <cite>dimA</cite> : (total) dimension of the systems that appear <cite>after</cite> in the tensor product order
:param Returns:
:param :
:type : return: sub-system operator in the extended Hilbert space</p>
<p class="rubric">Examples</p>
<p>TODO Update these
&gt;&gt;&gt; szQ1 = compositeOp(operator=sigmaz(), dimB=0, dimA=2)
&gt;&gt;&gt; szQ2 = compositeOp(operator=sigmaz(), dimB=2, dimA=0)
&gt;&gt;&gt; print(szQ1.A)
[[ 1.  0.  0.  0.]
[ 0.  1.  0.  0.]
[ 0.  0. -1.  0.]
[ 0.  0.  0. -1.]]
&gt;&gt;&gt; print(szQ2.A)
[[ 1.  0.  0.  0.]
[ 0. -1.  0.  0.]
[ 0.  0.  1.  0.]
[ 0.  0.  0. -1.]]</p>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.create">
<code class="sig-name descname">create</code><span class="sig-paren">(</span><em class="sig-param">dimension: int</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#create"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.create" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the bosonic <cite>creation</cite> operator</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>dimension</cite> : dimension of the Hilbert space
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: bosonic <cite>creation</cite> operator for dimension dimension</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">create</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(1, 0)      1.0</span>
<span class="go">(2, 1)      1.4142135623730951</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">create</span> <span class="o">=</span> <span class="n">create</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.         0.         0.        ]</span>
<span class="go">[1.         0.         0.        ]</span>
<span class="go">[0.         1.41421356 0.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.destroy">
<code class="sig-name descname">destroy</code><span class="sig-paren">(</span><em class="sig-param">dimension: int</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#destroy"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.destroy" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the bosonic <cite>annihilation</cite> operator</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>dimension</cite> : dimension of the Hilbert space
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: bosonic <cite>annihilation</cite> operator for dimension dimension</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">annihilation</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(0, 1)      1.0</span>
<span class="go">(1, 2)      1.4142135623730951</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">annihilation</span> <span class="o">=</span> <span class="n">destroy</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.         1.         0.        ]</span>
<span class="go">[0.         0.         1.41421356]</span>
<span class="go">[0.         0.         0.        ]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.displacement">
<code class="sig-name descname">displacement</code><span class="sig-paren">(</span><em class="sig-param">alpha: complex</em>, <em class="sig-param">dim: int</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#displacement"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.displacement" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the displacement operator for a given displacement parameter alpha</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>alpha</cite> : complex number, the displacement parameter
:param :
:type : param dim: dimension of the Hilbert space
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Displacement operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">disp</span> <span class="o">=</span> <span class="n">displacement</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[ 0.60605894+0.j          0.        +0.6100857j  -0.41242505+0.j       0.        -0.30065525j]</span>
<span class="go">[ 0.        +0.6100857j   0.02280184+0.j          0.        +0.34204129j        -0.71434114+0.j]</span>
<span class="go">[-0.41242505+0.j          0.        +0.34204129j -0.56045527+0.j        0.        +0.63150869j]</span>
<span class="go">[ 0.        -0.30065525j -0.71434114+0.j          0.        +0.63150869j        0.02280184+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">disp</span> <span class="o">=</span> <span class="n">displacement</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">(0, 0)      (0.6060589372864117+0j)</span>
<span class="go">(1, 0)      0.610085698426889j</span>
<span class="go">(2, 0)      (-0.41242505189886125+0j)</span>
<span class="go">(3, 0)      (-0-0.3006552538647247j)</span>
<span class="go">(0, 1)      0.610085698426889j</span>
<span class="go">(1, 1)      (0.02280183542861441+0j)</span>
<span class="go">(2, 1)      0.3420412936689465j</span>
<span class="go">(3, 1)      (-0.7143411442030587+0j)</span>
<span class="go">(0, 2)      (-0.4124250518988613+0j)</span>
<span class="go">(1, 2)      0.34204129366894637j</span>
<span class="go">(2, 2)      (-0.5604552664291825+0j)</span>
<span class="go">(3, 2)      0.6315086890322961j</span>
<span class="go">(0, 3)      -0.3006552538647247j</span>
<span class="go">(1, 3)      (-0.7143411442030586+0j)</span>
<span class="go">(2, 3)      0.6315086890322962j</span>
<span class="go">(3, 3)      (0.02280183542861464+0j)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.identity">
<code class="sig-name descname">identity</code><span class="sig-paren">(</span><em class="sig-param">dimension: int</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#identity"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.identity" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the identity operator</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>dimension</cite> : dimension of the Hilbert space
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: identity operator for dimension dimension</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">identity</span> <span class="o">=</span> <span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(0, 0)      1.0</span>
<span class="go">(1, 1)      1.0</span>
<span class="go">(2, 2)      1.0</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">identity</span> <span class="o">=</span> <span class="n">identity</span><span class="p">(</span><span class="mi">3</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[1. 0. 0.]</span>
<span class="go">[0. 1. 0.]</span>
<span class="go">[0. 0. 1.]]</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.number">
<code class="sig-name descname">number</code><span class="sig-paren">(</span><em class="sig-param">dimension: int</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#number"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.number" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the (bosonic) number operator</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param dimension : dimension of the Hilbert space
:param :
:type : param sparse : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: number operator for dimension dimension</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">numberArray</span> <span class="o">=</span> <span class="n">number</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0 0 0]</span>
<span class="go">[0 1 0]</span>
<span class="go">[0 0 2]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">numberSparse</span> <span class="o">=</span> <span class="n">number</span><span class="p">(</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(0, 0)      0</span>
<span class="go">(1, 1)      1</span>
<span class="go">(2, 2)      2</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.operatorPow">
<code class="sig-name descname">operatorPow</code><span class="sig-paren">(</span><em class="sig-param">op: Callable</em>, <em class="sig-param">dim: int</em>, <em class="sig-param">power: int</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#operatorPow"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.operatorPow" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates a quantum operator for given function reference <cite>op</cite> and raises to a <cite>power</cite></p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>op</cite> : reference to the function (in here) for the operator
:param :
:type : param <cite>dim</cite> : dimension of the Hilbert space
:param :
:type : param <cite>power</cite> : power that the operator to be raised
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: an operator raised to a power</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squareSigmaX</span> <span class="o">=</span> <span class="n">operatorPow</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">sigmax</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[1 0]</span>
<span class="go">[0 1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squareSigmaX</span> <span class="o">=</span> <span class="n">operatorPow</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">sigmax</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="go">(0, 0)      1</span>
<span class="go">(1, 1)      1</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cubedSigmaX</span> <span class="o">=</span> <span class="n">operatorPow</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">sigmax</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">3</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0 1]</span>
<span class="go">[1 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">cubedSigmaX</span> <span class="o">=</span> <span class="n">operatorPow</span><span class="p">(</span><span class="n">op</span><span class="o">=</span><span class="n">sigmax</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">power</span><span class="o">=</span><span class="mi">3</span><span class="p">)</span>
<span class="go">(1, 0)      1</span>
<span class="go">(0, 1)      1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.parityEXP">
<code class="sig-name descname">parityEXP</code><span class="sig-paren">(</span><em class="sig-param">HamiltonianCavity: Matrix</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#parityEXP"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.parityEXP" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the parity operator by exponentiation a given Hamiltonian</p>
<p>Keeps sparse/array as sparse/array.</p>
<p>:param :
:type : param <cite>HamiltonianCavity</cite> : dimension of the Hilbert space</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Parity operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">ham</span> <span class="o">=</span> <span class="n">number</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parityEXP</span> <span class="o">=</span> <span class="n">parityEXP</span><span class="p">(</span><span class="n">HamiltonianCavity</span><span class="o">=</span><span class="n">ham</span><span class="p">)</span> <span class="c1"># returns an array since ham is an array</span>
<span class="go">[[ 1.+0.0000000e+00j  0.+0.0000000e+00j  0.+0.0000000e+00j  0.+0.0000000e+00j  0.+0.0000000e+00j]</span>
<span class="go">[ 0.+0.0000000e+00j -1.+1.2246468e-16j  0.+0.0000000e+00j  0.+0.0000000e+00j  0.+0.0000000e+00j]</span>
<span class="go">[ 0.+0.0000000e+00j  0.+0.0000000e+00j  1.-2.4492936e-16j  0.+0.0000000e+00j  0.+0.0000000e+00j]</span>
<span class="go">[ 0.+0.0000000e+00j  0.+0.0000000e+00j  0.+0.0000000e+00j  -1.+3.6739404e-16j  0.+0.0000000e+00j]</span>
<span class="go">[ 0.+0.0000000e+00j  0.+0.0000000e+00j  0.+0.0000000e+00j  0.+0.0000000e+00j  1.-4.8985872e-16j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">ham</span> <span class="o">=</span> <span class="n">number</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">parityEXP</span> <span class="o">=</span> <span class="n">parityEXP</span><span class="p">(</span><span class="n">HamiltonianCavity</span><span class="o">=</span><span class="n">ham</span><span class="p">)</span> <span class="c1"># returns a sparse since ham is a sparse</span>
<span class="go">(0, 0)      (1+0j)</span>
<span class="go">(0, 1)      0j</span>
<span class="go">(1, 1)      (-1+1.2246467991473532e-16j)</span>
<span class="go">(1, 2)      -0j</span>
<span class="go">(2, 2)      (1-2.4492935982947064e-16j)</span>
<span class="go">(2, 3)      0j</span>
<span class="go">(3, 3)      (-1+3.6739403974420594e-16j)</span>
<span class="go">(3, 4)      -0j</span>
<span class="go">(4, 4)      (1-4.898587196589413e-16j)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.paritySUM">
<code class="sig-name descname">paritySUM</code><span class="sig-paren">(</span><em class="sig-param">dimension: int</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#paritySUM"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.paritySUM" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the parity operator by explicitly placing alternating +/- into a matrix</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>dimension</cite> : dimension of the Hilbert space
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Parity operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">paritySum</span> <span class="o">=</span> <span class="n">paritySUM</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">5</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[ 1.  0.  0.  0.  0.]</span>
<span class="go">[ 0. -1.  0.  0.  0.]</span>
<span class="go">[ 0.  0.  1.  0.  0.]</span>
<span class="go">[ 0.  0.  0. -1.  0.]</span>
<span class="go">[ 0.  0.  0.  0.  1.]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">paritySum</span> <span class="o">=</span> <span class="n">paritySUM</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">5</span><span class="p">)</span>
<span class="go">(0, 0)      1.0</span>
<span class="go">(1, 1)      -1.0</span>
<span class="go">(2, 2)      1.0</span>
<span class="go">(3, 3)      -1.0</span>
<span class="go">(4, 4)      1.0</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.sigmam">
<code class="sig-name descname">sigmam</code><span class="sig-paren">(</span><em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#sigmam"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.sigmam" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the <cite>Pauli</cite> sigma - operator, i.e. 2D Fermionic destruction operator</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>dimension</cite> : dimension of the Hilbert space (2 by default)
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>Pauli</cite> sigma - operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sm</span> <span class="o">=</span> <span class="n">sigmam</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0 0]</span>
<span class="go">[1 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sm</span> <span class="o">=</span> <span class="n">sigmam</span><span class="p">()</span>
<span class="go">(1, 0)      1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.sigmap">
<code class="sig-name descname">sigmap</code><span class="sig-paren">(</span><em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#sigmap"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.sigmap" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the <cite>Pauli</cite> sigma + operator, i.e. 2D Fermionic creation operator</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>dimension</cite> : dimension of the Hilbert space (2 by default)
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>Pauli</cite> sigma + operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span> <span class="o">=</span> <span class="n">sigmap</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0 1]</span>
<span class="go">[0 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sp</span> <span class="o">=</span> <span class="n">sigmap</span><span class="p">()</span>
<span class="go">(0, 1)      1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.sigmax">
<code class="sig-name descname">sigmax</code><span class="sig-paren">(</span><em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#sigmax"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.sigmax" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the <cite>Pauli</cite> sigma x operator</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>dimension</cite> : dimension of the Hilbert space (2 by default)
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>Pauli</cite> sigma x operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sx</span> <span class="o">=</span> <span class="n">sigmax</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0 1]</span>
<span class="go">[1 0]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sx</span> <span class="o">=</span> <span class="n">sigmax</span><span class="p">()</span>
<span class="go">(1, 0)      1</span>
<span class="go">(0, 1)      1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.sigmay">
<code class="sig-name descname">sigmay</code><span class="sig-paren">(</span><em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#sigmay"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.sigmay" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the <cite>Pauli</cite> sigma y operator</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>dimension</cite> : dimension of the Hilbert space (2 by default)
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>Pauli</cite> sigma y operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sy</span> <span class="o">=</span> <span class="n">sigmay</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.+0.j 0.-1.j]</span>
<span class="go">[0.+1.j 0.+0.j]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sy</span> <span class="o">=</span> <span class="n">sigmay</span><span class="p">()</span>
<span class="go">(1, 0)      1j</span>
<span class="go">(0, 1)      (-0-1j)</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.sigmaz">
<code class="sig-name descname">sigmaz</code><span class="sig-paren">(</span><em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#sigmaz"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.sigmaz" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the <cite>Pauli</cite> sigma z operator</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>dimension</cite> : dimension of the Hilbert space (2 by default)
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: <cite>Pauli</cite> sigma z operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">sz</span> <span class="o">=</span> <span class="n">sigmaz</span><span class="p">(</span><span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[ 1  0]</span>
<span class="go">[ 0 -1]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">sz</span> <span class="o">=</span> <span class="n">sigmaz</span><span class="p">()</span>
<span class="go">(0, 0)      1</span>
<span class="go">(1, 1)      -1</span>
</pre></div>
</div>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.operators.squeeze">
<code class="sig-name descname">squeeze</code><span class="sig-paren">(</span><em class="sig-param">alpha: complex</em>, <em class="sig-param">dim: int</em>, <em class="sig-param">sparse: bool = True</em><span class="sig-paren">)</span> &#x2192; Matrix<a class="reference internal" href="_modules/qTools/QuantumToolbox/operators.html#squeeze"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.operators.squeeze" title="Permalink to this definition">¶</a></dt>
<dd><p>Creates the squeezing operator for a given squeezing parameter alpha</p>
<p>Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)</p>
<p>:param :
:type : param <cite>alpha</cite> : complex number, the squeezing parameter
:param :
:type : param dim: dimension of the Hilbert space
:param :
:type : param <cite>sparse</cite> : boolean for sparse or not (array)</p>
<dl class="field-list simple">
<dt class="field-odd">Returns</dt>
<dd class="field-odd"><p></p>
</dd>
<dt class="field-even">Return type</dt>
<dd class="field-even"><p>return: Squeezing operator</p>
</dd>
</dl>
<p class="rubric">Examples</p>
<div class="doctest highlight-default notranslate"><div class="highlight"><pre><span></span><span class="gp">&gt;&gt;&gt; </span><span class="n">squeeze</span> <span class="o">=</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="go">[[0.7602446 +0.j         0.        +0.j         0.        -0.64963694j      0.        +0.j        ]</span>
<span class="go">[0.        +0.j         0.33918599+0.j         0.        +0.j               0.        -0.94071933j]</span>
<span class="go">[0.        -0.64963694j 0.        +0.j         0.7602446 +0.j               0.        +0.j        ]</span>
<span class="go">[0.        +0.j         0.        -0.94071933j 0.        +0.j               0.33918599+0.j        ]]</span>
<span class="gp">&gt;&gt;&gt; </span><span class="n">squeeze</span> <span class="o">=</span> <span class="n">squeeze</span><span class="p">(</span><span class="n">alpha</span><span class="o">=</span><span class="mi">1</span><span class="n">j</span><span class="p">,</span> <span class="n">dim</span><span class="o">=</span><span class="mi">4</span><span class="p">)</span>
<span class="go">(0, 0)      (0.7602445970756301+0j)</span>
<span class="go">(2, 0)      -0.6496369390800625j</span>
<span class="go">(1, 1)      (0.3391859889869473+0j)</span>
<span class="go">(3, 1)      -0.940719333741444j</span>
<span class="go">(0, 2)      -0.6496369390800625j</span>
<span class="go">(2, 2)      (0.7602445970756302+0j)</span>
<span class="go">(1, 3)      -0.9407193337414442j</span>
<span class="go">(3, 3)      (0.33918598898694713+0j)</span>
</pre></div>
</div>
</dd></dl>

</div>
</div>
<div class="section" id="module-qTools.QuantumToolbox.quasiProbabilities">
<span id="qtools-quantumtoolbox-quasiprobabilities-module"></span><h2>qTools.QuantumToolbox.quasiProbabilities module<a class="headerlink" href="#module-qTools.QuantumToolbox.quasiProbabilities" title="Permalink to this headline">¶</a></h2>
<p>Module of functions to calculate quasi-probability distributions (adapted from qutip).</p>
<dl class="method">
<dt>
<code class="sig-name descname">:Wigner : An iterative method to evaluate the Wigner functions for the Fock state :math:`|m&gt;&lt;n|`.</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:HusimiQ : Q-function of a given state vector or density matrix at points `xvec + i * yvec`.</code></dt>
<dd></dd></dl>

<dl class="method">
<dt>
<code class="sig-name descname">:_qfuncPure : Calculate the Q-function for a pure state.</code></dt>
<dd></dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.quasiProbabilities.HusimiQ">
<code class="sig-name descname">HusimiQ</code><span class="sig-paren">(</span><em class="sig-param">state: Matrix, xvec: Union[numpy.ndarray, list], g: float = 1.4142135623730951</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/qTools/QuantumToolbox/quasiProbabilities.html#HusimiQ"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.quasiProbabilities.HusimiQ" title="Permalink to this definition">¶</a></dt>
<dd><p>Q-function of a given state vector or density matrix at points <cite>xvec + i * yvec</cite></p>
<dl class="field-list simple">
<dt class="field-odd">Parameters</dt>
<dd class="field-odd"><ul class="simple">
<li><p><strong>state</strong> (<em>qobj</em>) – A state vector or density matrix.</p></li>
<li><p><strong>xvec</strong> (<em>array_like</em>) – x-coordinates at which to calculate the Wigner function.</p></li>
<li><p><strong>yvec</strong> (<em>array_like</em>) – y-coordinates at which to calculate the Wigner function.</p></li>
<li><p><strong>g</strong> (<em>float</em>) – Scaling factor for <cite>a = 0.5 * g * (x + iy)</cite>, default <cite>g = sqrt(2)</cite>.</p></li>
</ul>
</dd>
<dt class="field-even">Returns</dt>
<dd class="field-even"><p><strong>Q</strong> – Values representing the Q-function calculated over the specified range
[xvec,yvec].</p>
</dd>
<dt class="field-odd">Return type</dt>
<dd class="field-odd"><p>array</p>
</dd>
</dl>
</dd></dl>

<dl class="function">
<dt id="qTools.QuantumToolbox.quasiProbabilities.Wigner">
<code class="sig-name descname">Wigner</code><span class="sig-paren">(</span><em class="sig-param">rho: Matrix, xvec: Union[numpy.ndarray, list], g: float = 1.4142135623730951</em><span class="sig-paren">)</span> &#x2192; numpy.ndarray<a class="reference internal" href="_modules/qTools/QuantumToolbox/quasiProbabilities.html#Wigner"><span class="viewcode-link">[source]</span></a><a class="headerlink" href="#qTools.QuantumToolbox.quasiProbabilities.Wigner" title="Permalink to this definition">¶</a></dt>
<dd><p>An iterative method to evaluate the Wigner functions for the Fock state <img class="math" src="_images/math/31b773e57a1edac95490f9f6c0d179b0d40fac3e.png" alt="|m&gt;&lt;n|"/></p>
<p>The Wigner function is calculated as
<img class="math" src="_images/math/185fa2432aff3024a222e5cd491c6de39d1e1bb1.png" alt="W = \sum_{mn} \rho_{mn} W_{mn}"/> where <img class="math" src="_images/math/66ee3fc9a8ab287c0b4b4623e05195c7557c2f2a.png" alt="W_{mn}"/> is the Wigner
function for the density matrix <img class="math" src="_images/math/31b773e57a1edac95490f9f6c0d179b0d40fac3e.png" alt="|m&gt;&lt;n|"/>.</p>
<p>In this implementation, for each row m, Wlist contains the Wigner functions
Wlist = [0, …, W_mm, …, W_mN]. As soon as one W_mn Wigner function is
calculated, the corresponding contribution is added to the total Wigner
function, weighted by the corresponding element in the density matrix
<img class="math" src="_images/math/c48a0b9a1e5c21ae1743d0bd2acb8241e458e5f6.png" alt="rho_{mn}"/>.</p>
<p>:param :
:type : param <cite>rho</cite> : density matrix or ket state
:param :
:type : param <cite>xvec</cite> : multi-dimensional array for the (coarse-grained) Phase space</p>
</dd></dl>

</div>
<div class="section" id="module-qTools.QuantumToolbox">
<span id="module-contents"></span><h2>Module contents<a class="headerlink" href="#module-qTools.QuantumToolbox" title="Permalink to this headline">¶</a></h2>
</div>
</div>


           </div>
           
          </div>
          <footer>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Cahit Kargi
      <span class="lastupdated">
        Last updated on 2020/05/14.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>