

<!DOCTYPE html>
<!--[if IE 8]><html class="no-js lt-ie9" lang="en" > <![endif]-->
<!--[if gt IE 8]><!--> <html class="no-js" lang="en" > <!--<![endif]-->
<head>
  <meta charset="utf-8">
  
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  
  <title># How-to-use functions in states.py of QuantumToolbox &mdash; Quantum Simulations 1 documentation</title>
  

  
  
  
  

  
  <script type="text/javascript" src="../../_static/js/modernizr.min.js"></script>
  
    
      <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
        <script src="../../_static/jquery.js"></script>
        <script src="../../_static/underscore.js"></script>
        <script src="../../_static/doctools.js"></script>
        <script src="../../_static/language_data.js"></script>
        <script src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
        <script src="https://unpkg.com/@jupyter-widgets/html-manager@^0.18.0/dist/embed-amd.js"></script>
        <script crossorigin="anonymous" integrity="sha256-Ae2Vz/4ePdIu6ZyI/5ZGsYnb+m0JlOmKPjt6XZ9JJkA=" src="https://cdnjs.cloudflare.com/ajax/libs/require.js/2.3.4/require.min.js"></script>
    
    <script type="text/javascript" src="../../_static/js/theme.js"></script>

    

  
  <link rel="stylesheet" href="../../_static/css/theme.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/style.css" type="text/css" />
  <link rel="stylesheet" href="../../_static/jupyter-sphinx.css" type="text/css" />
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
    <link rel="prev" title="QuantumToolbox Demos" href="Demos.html" /> 
</head>

<body class="wy-body-for-nav">

   
  <div class="wy-grid-for-nav">
    
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #051988" >
          

          
            <a href="../../index.html" class="icon icon-home"> Quantum Simulations
          

          
          </a>

          
            
            
          

          
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>

          
        </div>

        <div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="main navigation">
          
            
            
              
            
            
              <ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../qTools.QuantumToolbox.html">QuantumToolbox</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="Demos.html">Demos</a><ul class="current">
<li class="toctree-l2 current"><a class="current reference internal" href="#"># How-to-use functions in states.py of QuantumToolbox</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-basis">## basis</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-completeBasis">## completeBasis</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-basisBra">## basisBra</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-zeros">## zeros</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-superPos">## superPos</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-densityMatrix">## densityMatrix</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-completeBasisMat">## completeBasisMat</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-normalise---normaliseKet---normaliseMat">## normalise - normaliseKet - normaliseMat</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-compositeState">## compositeState</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-tensorProd">## tensorProd</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-partialTrace">## partialTrace</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-mat2Vec">## mat2Vec</a></li>
<li class="toctree-l2"><a class="reference internal" href="###-vec2mat">## vec2mat</a></li>
</ul>
</li>
</ul>

            
          
        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap">

      
      <nav class="wy-nav-top" aria-label="top navigation">
        
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../index.html">Quantum Simulations</a>
        
      </nav>


      <div class="wy-nav-content">
        
        <div class="rst-content">
        
          















<div role="navigation" aria-label="breadcrumbs navigation">

  <ul class="wy-breadcrumbs">
    
      <li><a href="../../index.html">Docs</a> &raquo;</li>
        
          <li><a href="../qTools.QuantumToolbox.html">QuantumToolbox</a> &raquo;</li>
        
          <li><a href="Demos.html">QuantumToolbox Demos</a> &raquo;</li>
        
      <li># How-to-use functions in states.py of QuantumToolbox</li>
    
    
      <li class="wy-breadcrumbs-aside">
        
            
            <a href="../../_sources/QuantumToolbox/Demos/0_states.ipynb" rel="nofollow"> View page source</a>
          
        
      </li>
    
  </ul>

  
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
            
  
<style>
/* CSS for nbsphinx extension */

/* remove conflicting styling from Sphinx themes */
div.nbinput.container,
div.nbinput.container div.prompt,
div.nbinput.container div.input_area,
div.nbinput.container div[class*=highlight],
div.nbinput.container div[class*=highlight] pre,
div.nboutput.container,
div.nboutput.container div.prompt,
div.nboutput.container div.output_area,
div.nboutput.container div[class*=highlight],
div.nboutput.container div[class*=highlight] pre {
    background: none;
    border: none;
    padding: 0 0;
    margin: 0;
    box-shadow: none;
}

/* avoid gaps between output lines */
div.nboutput.container div[class*=highlight] pre {
    line-height: normal;
}

/* input/output containers */
div.nbinput.container,
div.nboutput.container {
    display: -webkit-flex;
    display: flex;
    align-items: flex-start;
    margin: 0;
    width: 100%;
}
@media (max-width: 540px) {
    div.nbinput.container,
    div.nboutput.container {
        flex-direction: column;
    }
}

/* input container */
div.nbinput.container {
    padding-top: 5px;
}

/* last container */
div.nblast.container {
    padding-bottom: 5px;
}

/* input prompt */
div.nbinput.container div.prompt pre {
    color: #307FC1;
}

/* output prompt */
div.nboutput.container div.prompt pre {
    color: #BF5B3D;
}

/* all prompts */
div.nbinput.container div.prompt,
div.nboutput.container div.prompt {
    width: 4.5ex;
    padding-top: 5px;
    position: relative;
    user-select: none;
}

div.nbinput.container div.prompt > div,
div.nboutput.container div.prompt > div {
    position: absolute;
    right: 0;
    margin-right: 0.3ex;
}

@media (max-width: 540px) {
    div.nbinput.container div.prompt,
    div.nboutput.container div.prompt {
        width: unset;
        text-align: left;
        padding: 0.4em;
    }
    div.nboutput.container div.prompt.empty {
        padding: 0;
    }

    div.nbinput.container div.prompt > div,
    div.nboutput.container div.prompt > div {
        position: unset;
    }
}

/* disable scrollbars on prompts */
div.nbinput.container div.prompt pre,
div.nboutput.container div.prompt pre {
    overflow: hidden;
}

/* input/output area */
div.nbinput.container div.input_area,
div.nboutput.container div.output_area {
    -webkit-flex: 1;
    flex: 1;
    overflow: auto;
}
@media (max-width: 540px) {
    div.nbinput.container div.input_area,
    div.nboutput.container div.output_area {
        width: 100%;
    }
}

/* input area */
div.nbinput.container div.input_area {
    border: 1px solid #e0e0e0;
    border-radius: 2px;
    background: #f5f5f5;
}

/* override MathJax center alignment in output cells */
div.nboutput.container div[class*=MathJax] {
    text-align: left !important;
}

/* override sphinx.ext.imgmath center alignment in output cells */
div.nboutput.container div.math p {
    text-align: left;
}

/* standard error */
div.nboutput.container div.output_area.stderr {
    background: #fdd;
}

/* ANSI colors */
.ansi-black-fg { color: #3E424D; }
.ansi-black-bg { background-color: #3E424D; }
.ansi-black-intense-fg { color: #282C36; }
.ansi-black-intense-bg { background-color: #282C36; }
.ansi-red-fg { color: #E75C58; }
.ansi-red-bg { background-color: #E75C58; }
.ansi-red-intense-fg { color: #B22B31; }
.ansi-red-intense-bg { background-color: #B22B31; }
.ansi-green-fg { color: #00A250; }
.ansi-green-bg { background-color: #00A250; }
.ansi-green-intense-fg { color: #007427; }
.ansi-green-intense-bg { background-color: #007427; }
.ansi-yellow-fg { color: #DDB62B; }
.ansi-yellow-bg { background-color: #DDB62B; }
.ansi-yellow-intense-fg { color: #B27D12; }
.ansi-yellow-intense-bg { background-color: #B27D12; }
.ansi-blue-fg { color: #208FFB; }
.ansi-blue-bg { background-color: #208FFB; }
.ansi-blue-intense-fg { color: #0065CA; }
.ansi-blue-intense-bg { background-color: #0065CA; }
.ansi-magenta-fg { color: #D160C4; }
.ansi-magenta-bg { background-color: #D160C4; }
.ansi-magenta-intense-fg { color: #A03196; }
.ansi-magenta-intense-bg { background-color: #A03196; }
.ansi-cyan-fg { color: #60C6C8; }
.ansi-cyan-bg { background-color: #60C6C8; }
.ansi-cyan-intense-fg { color: #258F8F; }
.ansi-cyan-intense-bg { background-color: #258F8F; }
.ansi-white-fg { color: #C5C1B4; }
.ansi-white-bg { background-color: #C5C1B4; }
.ansi-white-intense-fg { color: #A1A6B2; }
.ansi-white-intense-bg { background-color: #A1A6B2; }

.ansi-default-inverse-fg { color: #FFFFFF; }
.ansi-default-inverse-bg { background-color: #000000; }

.ansi-bold { font-weight: bold; }
.ansi-underline { text-decoration: underline; }


div.nbinput.container div.input_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight] > pre,
div.nboutput.container div.output_area div[class*=highlight].math,
div.nboutput.container div.output_area.rendered_html,
div.nboutput.container div.output_area > div.output_javascript,
div.nboutput.container div.output_area:not(.rendered_html) > img{
    padding: 5px;
}

/* fix copybtn overflow problem in chromium (needed for 'sphinx_copybutton') */
div.nbinput.container div.input_area > div[class^='highlight'],
div.nboutput.container div.output_area > div[class^='highlight']{
    overflow-y: hidden;
}

/* hide copybtn icon on prompts (needed for 'sphinx_copybutton') */
.prompt a.copybtn {
    display: none;
}

/* Some additional styling taken form the Jupyter notebook CSS */
div.rendered_html table {
  border: none;
  border-collapse: collapse;
  border-spacing: 0;
  color: black;
  font-size: 12px;
  table-layout: fixed;
}
div.rendered_html thead {
  border-bottom: 1px solid black;
  vertical-align: bottom;
}
div.rendered_html tr,
div.rendered_html th,
div.rendered_html td {
  text-align: right;
  vertical-align: middle;
  padding: 0.5em 0.5em;
  line-height: normal;
  white-space: normal;
  max-width: none;
  border: none;
}
div.rendered_html th {
  font-weight: bold;
}
div.rendered_html tbody tr:nth-child(odd) {
  background: #f5f5f5;
}
div.rendered_html tbody tr:hover {
  background: rgba(66, 165, 245, 0.2);
}

/* CSS overrides for sphinx_rtd_theme */

/* 24px margin */
.nbinput.nblast.container,
.nboutput.nblast.container {
    margin-bottom: 19px;  /* padding has already 5px */
}

/* ... except between code cells! */
.nblast.container + .nbinput.container {
    margin-top: -19px;
}

.admonition > p:before {
    margin-right: 4px;  /* make room for the exclamation icon */
}

/* Fix math alignment, see https://github.com/rtfd/sphinx_rtd_theme/pull/686 */
.math {
    text-align: unset;
}
</style>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[1]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">qTools.QuantumToolbox.states</span> <span class="k">as</span> <span class="nn">qStates</span>
</pre></div>
</div>
</div>
<div class="section" id="#-How-to-use-functions-in-states.py-of-QuantumToolbox">
<h1># How-to-use functions in states.py of QuantumToolbox<a class="headerlink" href="##-How-to-use-functions-in-states.py-of-QuantumToolbox" title="Permalink to this headline">¶</a></h1>
<p>Each example is introduced in the order that the functions appear inside the file</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[2]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># Uncomment any (or both) of these two to print module docstrings</span>
<span class="c1">#print(qStates.__doc__)</span>
<span class="n">help</span><span class="p">(</span><span class="n">qStates</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Help on module qTools.QuantumToolbox.states in qTools.QuantumToolbox:

NAME
    qTools.QuantumToolbox.states - Module of functions to create and/or normalise quantum states.

DESCRIPTION
    Functions
    -------
    :basis : Creates a `ket` state for a given dimension with 1 at a given row
    :completeBasis : Creates a complete basis of `ket` states
    :basisBra : Creates a `bra` state for a given dimension with 1 at a given column
    :zeros : Creates a column matrix (ket) of zeros
    :superPos : Creates a `ket` superposition state

    :densityMatrix : Converts a `ket` state into ``density matrix``
    :completeBasisMat : Creates a complete basis of ``density matrices`` or convert a ``ket basis`` to ``density matrix``

    :normalise : Function to normalise `any` state (ket or density matrix)
    :normaliseKet : Function to normalise `ket` state
    :normaliseMat : Function to normalise a ``density matrix``

    :compositeState : Function to create ``composite ket`` states
    :tensorProd : ``missing docstring``
    :partialTrace : Calculates the partial trace of a `density matrix` of composite state

    :mat2Vec : Converts ``density matrix`` into ``density vector`` (used in super-operator representation)
    :vec2mat : Converts ``density vector`` into ``density matrix``

FUNCTIONS
    basis(dimension: int, state: int, sparse: bool = True) -&gt; ~Matrix
        Creates a `ket` state for a given dimension with 1 at a given row

        Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)

        Parameters
        ----------
        :param dimension : dimension of Hilbert space
        :param state : row to place 1, i.e. index for the populated state
        :param sparse : boolean for sparse or not (array)

        Returns
        -------
        :return : `ket` state with 1 at a given row

        Examples
        --------
        &gt;&gt;&gt; basis(2, 1)
        (0, 0)      1
        &gt;&gt;&gt; basis(2, 1, sparse=False)
        [[1]
        [0]]

    basisBra(dimension: int, state: int, sparse: bool = True) -&gt; ~Matrix
        Creates a `bra` state for a given dimension with 1 at a given column

        Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)

        Parameters
        ----------
        :param `dimension` : dimension of Hilbert space
        :param `state` : index number for the populated state
        :param `sparse` : boolean for sparse or not (array)

        Returns
        -------
        :return: `bra` state

        Examples
        --------
        &gt;&gt;&gt; basisBra(2, 1)
        (0, 0)      1
        &gt;&gt;&gt; basisBra(2, 1, sparse=False)
        [[1 0]]

    completeBasis(dimension: int, sparse: bool = True) -&gt; List[~Matrix]
        Creates a complete basis of `ket` states

        Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)

        Parameters
        ----------
        :param dimension : dimension of Hilbert space
        :param sparse : boolean for sparse or not (array)

        Returns
        -------
        :return : a list (complete basis) of `ket` states

        Examples
        --------
        &gt;&gt;&gt; completeBasis0 = completeBasis(2, sparse=False)
        &gt;&gt;&gt; for state in completeBasis0:
        &gt;&gt;&gt;    print(state)
        [[1]
        [0]]
        [[0]
        [1]]
        &gt;&gt;&gt; completeBasis1 = completeBasis(2)
        &gt;&gt;&gt; for state in completeBasis1:
        &gt;&gt;&gt;    print(state)
        (0, 0)      1
        (1, 0)      1

    completeBasisMat(dimension: Union[int, NoneType] = None, compKetBase: Union[List[~Matrix], NoneType] = None, sparse: bool = True) -&gt; List[~Matrix]
        Creates a complete basis of ``density matrices`` or convert a ket basis to density matrix for a given dimension.
        Note: This is not a complete basis for n-by-n matrices but for populations, i.e. diagonals.

        For a given basis, Keeps the sparse/array as sparse/array.
        For a given dimension, either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)

        If a complete basis is given, keeps the sparse/array as sparse/array

        Parameters
        ----------
        :param `dimension` : dimension of Hilbert space (or default None if a ket basis is given)
        :param `compKetBase`: a complete ket basis (or default None if dimension is given)
        :param `sparse` : boolean for sparse or not (array)

        Returns
        -------
        :return : a list (complete basis) of ``density matrices``

        Raises
        ------
        :ValueError : raised if both complete ket basis and dimension are None (default). Dimension is used to create

        Examples
        --------
        &gt;&gt;&gt; completeBasis0 = completeBasis(2, sparse=False)
        &gt;&gt;&gt; completeBasis1 = completeBasis(2)
        &gt;&gt;&gt; completeBasisMat0 = completeBasisMat(dimension=2, compKetBase=completeBasis0)
        &gt;&gt;&gt; for state in completeBasisMat0:
        &gt;&gt;&gt;    print(state)
        [[1 0]
        [0 0]]
        [[0 0]
        [0 1]]
        &gt;&gt;&gt; completeBasisMat1 = completeBasisMat(dimension=2, compKetBase=completeBasis1)
        &gt;&gt;&gt; for state in completeBasisMat1:
        &gt;&gt;&gt;    print(state)
        (0, 0)      1
        (1, 1)      1
        &gt;&gt;&gt; completeBasisMat01 = completeBasisMat(dimension=2, sparse=False)
        &gt;&gt;&gt; for state in completeBasisMat01:
        &gt;&gt;&gt;    print(state)
        [[1 0]
        [0 0]]
        [[0 0]
        [0 1]]
        &gt;&gt;&gt; completeBasisMat11 = completeBasisMat(dimension=2)
        &gt;&gt;&gt; for state in completeBasisMat11:
        &gt;&gt;&gt;    print(state)
        (0, 0)      1
        (1, 1)      1

    compositeState(dimensions: List[int], excitations: List[Union[Dict[int, float], List[int], int]], sparse: bool = True) -&gt; ~Matrix
        Function to create ``composite ket`` states

        Parameters
        ----------
        :param `dimensions` : list of dimensions for each sub-system of the composite quantum system
        :param `excitations` : list of state information for sub-systems \
            This list can have mixture of dict, list, and int values,
            which are used to create a superposition state for the corresponding sub-system \
            See: `superPos` function
        :param `sparse`: boolean for sparse or not (array)

        Returns
        -------
        :return: composite ket state

        Examples
        --------
        &gt;&gt;&gt; compositeState0 = compositeState(dimensions=[2, 2], excitations=[0,1], sparse=False)
        [[0]
        [1]
        [0]
        [0]]
        &gt;&gt;&gt; compositeState1 = compositeState(dimensions=[2, 2], excitations=[[0,1],1], sparse=False)
        [[0.        ]
        [0.70710678]
        [0.        ]
        [0.70710678]]
        &gt;&gt;&gt; compositeState2 = compositeState(dimensions=[2, 2], excitations=[0,{0:0.2, 1:0.8}], sparse=False)
        [[0.4472136 ]
        [0.89442719]
        [0.        ]
        [0.        ]]

    densityMatrix(ket: ~Matrix) -&gt; ~Matrix
        Converts a `ket` state into ``density matrix``

        Keeps the sparse/array as sparse/array

        Parameters
        ----------
        :param `ket` : ket state

        Returns
        -------
        :return: density Matrix

        Examples
        --------
        &gt;&gt;&gt; ket = basis(2, 0)
        &gt;&gt;&gt; mat = densityMatrix(ket)
        (0, 0)      1
        &gt;&gt;&gt; ket = basis(2, 0, False)
        &gt;&gt;&gt; mat = densityMatrix(ket)
        [[1 0]
        [0 0]]
        &gt;&gt;&gt; ket = superPos(2, [0,1], sparse=False)
        &gt;&gt;&gt; mat = densityMatrix(ket)
        [[0.5 0.5]
        [0.5 0.5]]
        &gt;&gt;&gt; ket = superPos(2, {0:0.2, 1:0.8}, sparse=False)
        &gt;&gt;&gt; mat = densityMatrix(ket)
        [[0.2 0.4]
        [0.4 0.8]]

    mat2Vec(denMat: ~Matrix) -&gt; ~Matrix
        Converts ``density matrix`` into ``density vector`` (used in super-operator respresentation)

        Keeps the sparse/array as sparse/array

        Parameters
        ----------
        :param `denMat`: density matrix to be converted

        Parameters
        ----------
        :return: density vector

        Examples
        --------
        &gt;&gt;&gt; denMat = densityMatrix(ket=basis(dimension=2, state=1, sparse=True))
        &gt;&gt;&gt; denVec = mat2Vec(denMat=denMat)
        [[0]
        [0]
        [0]
        [1]]

    normalise(state: ~Matrix) -&gt; ~Matrix
        Function to normalise `any` state (ket or density matrix)

        Keeps the sparse/array as sparse/array

        Parameters
        ----------
        :param `state` : state to be normalised

        Returns
        -------
        :return: normalised state

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; nonNormalisedKet = np.sqrt(0.2)*basis(2,1) + np.sqrt(0.8)*basis(2,0)
        &gt;&gt;&gt; normalisedKet = normalise(nonNormalisedKet)
        [[0.89442719]
        [0.4472136 ]]
        &gt;&gt;&gt; nonNormalisedMat = densityMatrix(nonNormalisedKet)
        &gt;&gt;&gt; normalisedMat = normalise(nonNormalisedMat)
        [[0.8 0.4]
        [0.4 0.2]]

    normaliseKet(ket: ~Matrix) -&gt; ~Matrix
        Function to normalise `ket` state

        Keeps the sparse/array as sparse/array

        Parameters
        ----------
        :param `state` : ket state to be normalised

        Returns
        -------
        :return: normalised `ket` state

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; nonNormalisedKet = np.sqrt(0.2)*basis(2,1) + np.sqrt(0.8)*basis(2,0)
        &gt;&gt;&gt; normalisedKet = normaliseKet(nonNormalisedKet)
        [[0.89442719]
        [0.4472136 ]]

    normaliseMat(denMat: ~Matrix) -&gt; ~Matrix
        Function to normalise a ``density matrix``

        Keeps the sparse/array as sparse/array

        Parameters
        ----------
        :param `state` : ``density matrix`` to be normalised

        Returns
        -------
        :return: normalised ``density matrix``

        Examples
        --------
        &gt;&gt;&gt; import numpy as np
        &gt;&gt;&gt; nonNormalisedMat = densityMatrix(nonNormalisedKet)
        &gt;&gt;&gt; normalisedMat = normalise(nonNormalisedMat)
        [[0.8 0.4]
        [0.4 0.2]]

    partialTrace(keep: Union[numpy.ndarray, List[int]], dims: Union[numpy.ndarray, List[int]], state: ~Matrix) -&gt; numpy.ndarray
        Calculates the partial trace of a `density matrix` of composite state
        ρ_a = Tr_b(ρ)

        Adapted from: https://scicomp.stackexchange.com/questions/30052/calculate-partial-trace-of-an-outer-product-in-python

        Parameters
        ----------
        :param `keep` : An array of indices of the spaces to keep after being traced. For instance, if the space is
            A x B x C x D and we want to trace out B and D, keep = [0,2]
        dims : An array of the dimensions of each space. For instance, if the space is A x B x C x D,
            dims = [dim_A, dim_B, dim_C, dim_D]
        :param `state` : Matrix to trace

        Returns
        -------
        ρ_a : Traced matrix

        Examples
        --------
        &gt;&gt;&gt; compositeState0 = compositeState(dimensions=[2, 2], excitations=[0,1], sparse=False)
        &gt;&gt;&gt; stateFirstSystem0 = partialTrace(keep=[0], dims=[2, 2], state=compositeState0)
        [[1 0]
        [0 0]]
        &gt;&gt;&gt; stateSecondSystem0 = partialTrace(keep=[1], dims=[2, 2], state=compositeState0)
        [[0 0]
        [0 1]]
        &gt;&gt;&gt; compositeState1 = compositeState(dimensions=[2, 2], excitations=[[0,1],1], sparse=False)
        [[0. 0.]
        [0. 1.]]
        &gt;&gt;&gt; stateFirstSystem1 = partialTrace(keep=[0], dims=[2, 2], state=compositeState1)
        [[0.5 0.5]
        [0.5 0.5]]
        &gt;&gt;&gt; stateSecondSystem1 = partialTrace(keep=[1], dims=[2, 2], state=compositeState1)
        &gt;&gt;&gt; compositeState2 = compositeState(dimensions=[2, 2], excitations=[0,{0:0.2, 1:0.8}], sparse=False)
        &gt;&gt;&gt; stateFirstSystem2 = partialTrace(keep=[0], dims=[2, 2], state=compositeState2)
        [[1. 0.]
        [0. 0.]]
        &gt;&gt;&gt; stateSecondSystem2 = partialTrace(keep=[1], dims=[2, 2], state=compositeState2)
        [[0.2 0.4]
        [0.4 0.8]]

    superPos(dimension: int, excitations: Union[Dict[int, float], List[int], int], sparse: bool = True) -&gt; ~Matrix
        Creates a `ket` superposition state

        Function to create a ``superposition ket`` state from a given `dictionary` or `list`, \
        or `ket` state from a given `integer` (in this case, it is equivalent to basis function)

        Parameters
        ----------
        :param `dimension`: dimension of Hilbert space
        :param `excitations`: There are 3 possible uses of this \
            1) a `dictionary` with state:population (key:value), e.g. {0:0.2, 1:0.4, 2:0.4} \
            2) a `list` (e.g. [0,1,2]) for equally populated super-position \
            3) an `integer`, which is equivalent to basis function

        Returns
        -------
        :return: a superposition `ket` state

        Examples
        --------
        &gt;&gt;&gt; ket = superPos(2, {0:0.2, 1:0.8}, sparse=False)
        [[0.4472136 ]
        [0.89442719]]
        &gt;&gt;&gt; ket = superPos(2, [0,1], sparse=False)
        [[0.70710678]
        [0.70710678]]
        &gt;&gt;&gt; ket = superPos(2, 1, sparse=False)
        [[0.]
        [1.]]

    tensorProd(*args: ~Matrix) -&gt; ~Matrix
        Function to calculate tensor product of given states (in the given order).

        The matrices can be sparse/ndarray, but they all should be the same either sparse/ndarray not a mixture.

        Parameters
        ----------
        :param `*args` : state matrices (arbitary number of them)

        Returns
        -------
        :return: tensor product of given states (in the given order)

        Examples
        --------
        # TODO Create some examples both in here and the demo script

    vec2mat(vec: ~Matrix) -&gt; ~Matrix
        Converts ``density vector`` into ``density matrix``

        Keeps the sparse/array as sparse/array

        Parameters
        ----------
        :param `vec`: density vector to be converted

        Parameters
        ----------
        :return: density matrix

        Examples
        --------
        &gt;&gt;&gt; denMat = densityMatrix(ket=basis(dimension=2, state=1, sparse=True))
        [[0 0]
        [0 1]]
        &gt;&gt;&gt; denVec = mat2Vec(denMat=denMat)
        &gt;&gt;&gt; denMatConverted = vec2mat(vec=denVec)
        [[0 0]
        [0 1]]

    zeros(dimension: int, sparse: bool = True) -&gt; ~Matrix
        Creates a column matrix of zeros

        Either as sparse (&gt;&gt;&gt; sparse=True) or array (&gt;&gt;&gt; sparse=False)

        Parameters
        ----------
        :param `dimension` : dimension of Hilbert space

        Returns
        -------
        :return: ket of zeros

        Examples
        --------
        &gt;&gt;&gt; zeros(2)
        (0, 0)      0
        &gt;&gt;&gt; zeros(2, sparse=False)
        [[0]
        [0]]

DATA
    List = typing.List
    Matrix = ~Matrix
    Optional = typing.Optional
    intList = typing.List[int]
    matrixList = typing.List[~Matrix]
    ndOrListInt = typing.Union[numpy.ndarray, typing.List[int]]
    supInp = typing.Union[typing.Dict[int, float], typing.List[int], int]

FILE
    /Users/cahitkargi/VSCProjects/QuantumSimulations/qTools/QuantumToolbox/states.py


</pre></div></div>
</div>
</div>
<div class="section" id="##-basis">
<h1>## basis<a class="headerlink" href="###-basis" title="Permalink to this headline">¶</a></h1>
<p>This is a method to create ket states for a given dimension with 1 at a given row.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[3]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># sparse=True by default</span>
<span class="c1"># for dimension 2 and 1 at 0th element of the column matrix (see the print below)</span>
<span class="n">ketStateSparse</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">0</span><span class="p">)</span>
<span class="n">ketStateArray</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">0</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sparse ket&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ketStateSparse</span><span class="p">)</span>
<span class="c1"># You obtain the array by simply calling .A on the sparse matrix</span>
<span class="c1"># If sparse=True, function simply returns state.A</span>
<span class="c1"># so, these two are equivalent</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Array from Sparse ket&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ketStateSparse</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Array from basis function by sparse=False&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">ketStateArray</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Sparse ket
  (0, 0)        1
Array from Sparse ket
[[1]
 [0]]
Array from basis function by sparse=False
[[1]
 [0]]
</pre></div></div>
</div>
</div>
<div class="section" id="##-completeBasis">
<h1>## completeBasis<a class="headerlink" href="###-completeBasis" title="Permalink to this headline">¶</a></h1>
<p>This is a method to create a complete basis of ket states for a given dimension.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[4]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">completeBasisSparse</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">completeBasisArray</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sparse kets of the complete basis and array (.A) for each&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">completeBasisSparse</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Array kets of the complete basis&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">completeBasisArray</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Sparse kets of the complete basis and array (.A) for each
  (0, 0)        1
[[1]
 [0]]
  (1, 0)        1
[[0]
 [1]]
Array kets of the complete basis
[[1]
 [0]]
[[0]
 [1]]
</pre></div></div>
</div>
</div>
<div class="section" id="##-basisBra">
<h1>## basisBra<a class="headerlink" href="###-basisBra" title="Permalink to this headline">¶</a></h1>
<p>This is a method to create bra states for a given dimension.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[5]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># for dimension 2 and 1 at 1st element of the row matrix (see the print below)</span>
<span class="n">braStateSparse</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basisBra</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">)</span>
<span class="n">braStateArray</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">basisBra</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="mi">1</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sparse Bra and array (.A) from the sparse Bra&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">braStateSparse</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">braStateSparse</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Array Bra from basisBra function by sparse=False&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">braStateArray</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Sparse Bra and array (.A) from the sparse Bra
  (0, 1)        1
[[0 1]]
Array Bra from basisBra function by sparse=False
[[0 1]]
</pre></div></div>
</div>
</div>
<div class="section" id="##-zeros">
<h1>## zeros<a class="headerlink" href="###-zeros" title="Permalink to this headline">¶</a></h1>
<p>This is a method to create a column matrix of zeros for a given dimension.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[6]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># for dimension 2 and all the elements of the column matrix are 0 (see the print below)</span>
<span class="n">zerosSparse</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">zerosArray</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">zeros</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="kc">False</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sparse zeros (ket) and array (.A) from the sparse Bra&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">zerosSparse</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">zerosSparse</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Array zeros (ket) from basisBra function by sparse=False&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">zerosArray</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Sparse zeros (ket) and array (.A) from the sparse Bra
  (0, 0)        0
[[0]
 [0]]
Array zeros (ket) from basisBra function by sparse=False
[[0]
 [0]]
</pre></div></div>
</div>
</div>
<div class="section" id="##-superPos">
<h1>## superPos<a class="headerlink" href="###-superPos" title="Permalink to this headline">¶</a></h1>
<p>This is a method to create a super-position state for a given dimension. Depending on the second argument, this returns:</p>
<ol class="arabic simple">
<li><p>int: equivalent to basis, i.e. returns a ket state with a unit population at the given int</p></li>
<li><p>list: creates an equally populated super-position state from a list of integers</p></li>
<li><p>dict: creates a super-position by using the key as state int and the value as population</p></li>
</ol>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[7]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># 1 at 0th element of the column matrix (see the print below)</span>
<span class="n">superPosState0Sparse</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">superPos</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">excitations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="n">superPosState0Array</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">superPos</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">excitations</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># sqrt(0.5) at 0th and 1st elements of the column matrix, i.e. population of each state is 0.5</span>
<span class="n">superPosState1Sparse</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">superPos</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">])</span>
<span class="n">superPosState1Array</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">superPos</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>
<span class="c1"># sqrt(0.2) at 0th and sqrt(0.8) at 1st element of the column matrix, i.e. population of 0 is 0.2, and population of 1 is 0.8</span>
<span class="n">superPosState2Sparse</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">superPos</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mf">0.8</span><span class="p">})</span>
<span class="n">superPosState2Array</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">superPos</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="p">{</span><span class="mi">0</span><span class="p">:</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mf">0.8</span><span class="p">},</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Ket States&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState0Sparse</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState0Sparse</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState0Array</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Equal Super-position&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState1Sparse</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState1Array</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState1Array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState1Array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Super-position of given populations (keys of the dict)&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState2Sparse</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState2Sparse</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState2Array</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState2Array</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">superPosState2Array</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Ket States
  (1, 0)        1.0
[[0.]
 [1.]]
[[0.]
 [1.]]
Equal Super-position
  (0, 0)        0.7071067811865475
  (1, 0)        0.7071067811865475
[[0.70710678]
 [0.70710678]]
[0.5]
[0.5]
Super-position of given populations (keys of the dict)
  (0, 0)        0.44721359549995804
  (1, 0)        0.8944271909999161
[[0.4472136 ]
 [0.89442719]]
[[0.4472136 ]
 [0.89442719]]
[0.2]
[0.8]
</pre></div></div>
</div>
</div>
<div class="section" id="##-densityMatrix">
<h1>## densityMatrix<a class="headerlink" href="###-densityMatrix" title="Permalink to this headline">¶</a></h1>
<p>This is a method to create a density matrix for a given ket (or pure) state.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[8]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># density matrices of the super-position states created above. It creates sparse/array structure.</span>
<span class="n">densityMat2Sparse</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket</span><span class="o">=</span><span class="n">superPosState2Sparse</span><span class="p">)</span>
<span class="n">densityMat2Array</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">superPosState2Array</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Sparse density matrix from a given sparse ket and array (.A) from the sparse density matrix&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">densityMat2Sparse</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">densityMat2Sparse</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;Array density matrix from a given array ket&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">densityMat2Array</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
Sparse density matrix from a given sparse ket and array (.A) from the sparse density matrix
  (1, 0)        0.4000000000000002
  (0, 0)        0.2000000000000001
  (1, 1)        0.8000000000000004
  (0, 1)        0.4000000000000002
[[0.2 0.4]
 [0.4 0.8]]
Array density matrix from a given array ket
[[0.2 0.4]
 [0.4 0.8]]
</pre></div></div>
</div>
</div>
<div class="section" id="##-completeBasisMat">
<h1>## completeBasisMat<a class="headerlink" href="###-completeBasisMat" title="Permalink to this headline">¶</a></h1>
<p>This is a method to convert a complete basis of ket states to density matrices or create a complete basis of density matrices for a given dimension. Note: This is not a complete basis for n-by-n matrices but for populations, i.e. diagonals.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[9]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="n">completeBasisSparse</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="mi">2</span><span class="p">)</span>
<span class="n">completeBasisArray</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="n">completeBasisMat0Sparse</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasisMat</span><span class="p">(</span><span class="n">compKetBase</span><span class="o">=</span><span class="n">completeBasisSparse</span><span class="p">)</span>
<span class="n">completeBasisMat1Array</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasisMat</span><span class="p">(</span><span class="n">compKetBase</span><span class="o">=</span><span class="n">completeBasisArray</span><span class="p">)</span>

<span class="n">completeBasisMat01Sparse</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasisMat</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">)</span>
<span class="n">completeBasisMat11Array</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">completeBasisMat</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">False</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(Sparse) Matrix basis from given (sparse) ket basis&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">completeBasisMat0Sparse</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(Array) Matrix basis from given (array) ket basis&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">completeBasisMat1Array</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(Sparse) Matrix basis from given dimension by sparse=True (default)&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">completeBasisMat01Sparse</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;(Array) Matrix basis from given dimension by sparse=False&#39;</span><span class="p">)</span>
<span class="k">for</span> <span class="n">state</span> <span class="ow">in</span> <span class="n">completeBasisMat11Array</span><span class="p">:</span>
    <span class="nb">print</span><span class="p">(</span><span class="n">state</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
(Sparse) Matrix basis from given (sparse) ket basis
  (0, 0)        1
[[1 0]
 [0 0]]
  (1, 1)        1
[[0 0]
 [0 1]]
(Array) Matrix basis from given (array) ket basis
[[1 0]
 [0 0]]
[[0 0]
 [0 1]]
(Sparse) Matrix basis from given dimension by sparse=True (default)
  (0, 0)        1
[[1 0]
 [0 0]]
  (1, 1)        1
[[0 0]
 [0 1]]
(Array) Matrix basis from given dimension by sparse=False
[[1 0]
 [0 0]]
[[0 0]
 [0 1]]
</pre></div></div>
</div>
</div>
<div class="section" id="##-normalise---normaliseKet---normaliseMat">
<h1>## normalise - normaliseKet - normaliseMat<a class="headerlink" href="###-normalise---normaliseKet---normaliseMat" title="Permalink to this headline">¶</a></h1>
<p>normalise a method to normalise any given state. This method checks and if-else and calls either normaliseKet and normaliseMat.</p>
<p>normaliseKet and normaliseMat are normalisation methods respectively for a ket state and density matrix.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[10]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="kn">import</span> <span class="nn">numpy</span> <span class="k">as</span> <span class="nn">np</span>
<span class="c1"># create a non-normalised ket and density matrix</span>
<span class="n">nonNormalisedKet</span> <span class="o">=</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.2</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">1</span><span class="p">)</span> <span class="o">+</span> <span class="n">np</span><span class="o">.</span><span class="n">sqrt</span><span class="p">(</span><span class="mf">0.8</span><span class="p">)</span><span class="o">*</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="mi">2</span><span class="p">,</span><span class="mi">0</span><span class="p">)</span>
<span class="n">nonNormalisedDenMat</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">nonNormalisedKet</span><span class="p">)</span>

<span class="c1"># normalise these states</span>

<span class="c1"># normalisedKet = qStates.normaliseKet(ket=nonNormalisedKet)</span>
<span class="n">normalisedKet</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="n">state</span><span class="o">=</span><span class="n">nonNormalisedKet</span><span class="p">)</span>

<span class="c1">#normalisedDenMat = qStates.normaliseMat(denMat=nonNormalisedDenMat)</span>
<span class="n">normalisedDenMat</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">normalise</span><span class="p">(</span><span class="n">nonNormalisedDenMat</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">nonNormalisedKet</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">nonNormalisedDenMat</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">normalisedKet</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">normalisedDenMat</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>

<span class="c1"># see the populations in 1 and 0</span>
<span class="nb">print</span><span class="p">(</span><span class="n">normalisedKet</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">normalisedKet</span><span class="p">[</span><span class="mi">1</span><span class="p">]</span><span class="o">**</span><span class="mi">2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[[0.89442719]
 [0.4472136 ]]
[[0.8 0.4]
 [0.4 0.2]]
[[0.89442719]
 [0.4472136 ]]
[[0.8 0.4]
 [0.4 0.2]]
  (0, 0)        0.8000000000000004
  (0, 0)        0.2000000000000001
</pre></div></div>
</div>
</div>
<div class="section" id="##-compositeState">
<h1>## compositeState<a class="headerlink" href="###-compositeState" title="Permalink to this headline">¶</a></h1>
<p>This is a method to create ket state for a composite quantum system from a given list of sub-system dimensions and a list state informations.</p>
<p>This method can create super-position for a sub-state, so the list of state information can be a list of mixtures of int, list, and dict. (see superPos above to see how these are used)</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[11]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># composite states for two (qubit) 2D systems</span>

<span class="c1"># super-position state where first sub-system is in state 0 and second is in 1</span>
<span class="n">compositeState0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">compositeState</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># super-position state where first sub-system is in equal super-position of 0&amp;1 and second is in 1</span>
<span class="n">compositeState1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">compositeState</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[[</span><span class="mi">0</span><span class="p">,</span><span class="mi">1</span><span class="p">],</span><span class="mi">1</span><span class="p">],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="c1"># super-position state where first sub-system is in state 0 and second is in a super-position with 0.2 population in 0 and 0.8 in 1</span>
<span class="n">compositeState2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">compositeState</span><span class="p">(</span><span class="n">dimensions</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">excitations</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">,{</span><span class="mi">0</span><span class="p">:</span><span class="mf">0.2</span><span class="p">,</span> <span class="mi">1</span><span class="p">:</span><span class="mf">0.8</span><span class="p">}],</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">compositeState0</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">compositeState1</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">compositeState2</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>

<span class="c1"># above prints are not very instructive, so let&#39;s see the next tool, partialTrace.</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[[0]
 [1]
 [0]
 [0]]
[[0.        ]
 [0.70710678]
 [0.        ]
 [0.70710678]]
[[0.4472136 ]
 [0.89442719]
 [0.        ]
 [0.        ]]
</pre></div></div>
</div>
</div>
<div class="section" id="##-tensorProd">
<h1>## tensorProd<a class="headerlink" href="###-tensorProd" title="Permalink to this headline">¶</a></h1>
<p>This is a method to calculate tensor product of given states (in the given order).</p>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>
</pre></div>
</div>
</div>
</div>
<div class="section" id="##-partialTrace">
<h1>## partialTrace<a class="headerlink" href="###-partialTrace" title="Permalink to this headline">¶</a></h1>
<p>This is a method to take partial trace to trace-out some of the sub-systems.</p>
<p>Note: This function CANNOT keep sparse structure, i.e. always returns an array</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[12]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># partial traces of the composite states above.</span>
<span class="n">stateFirstSystem0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">compositeState0</span><span class="p">)</span>
<span class="n">stateSecondSystem0</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">compositeState0</span><span class="p">)</span>

<span class="n">stateFirstSystem1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">compositeState1</span><span class="p">)</span>
<span class="n">stateSecondSystem1</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">compositeState1</span><span class="p">)</span>

<span class="n">stateFirstSystem2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">compositeState2</span><span class="p">)</span>
<span class="n">stateSecondSystem2</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">partialTrace</span><span class="p">(</span><span class="n">keep</span><span class="o">=</span><span class="p">[</span><span class="mi">1</span><span class="p">],</span> <span class="n">dims</span><span class="o">=</span><span class="p">[</span><span class="mi">2</span><span class="p">,</span> <span class="mi">2</span><span class="p">],</span> <span class="n">state</span><span class="o">=</span><span class="n">compositeState2</span><span class="p">)</span>

<span class="c1"># print and see the states of the first sub-system in each composite state</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;States of first sub-system&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">stateFirstSystem0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">stateFirstSystem1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">stateFirstSystem2</span><span class="p">)</span>

<span class="c1"># print and see the states of the second sub-system in each composite state</span>
<span class="nb">print</span><span class="p">(</span><span class="s1">&#39;States of second sub-system&#39;</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">stateSecondSystem0</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">stateSecondSystem1</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">stateSecondSystem2</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
States of first sub-system
[[1 0]
 [0 0]]
[[0.5 0.5]
 [0.5 0.5]]
[[1. 0.]
 [0. 0.]]
States of second sub-system
[[0 0]
 [0 1]]
[[0. 0.]
 [0. 1.]]
[[0.2 0.4]
 [0.4 0.8]]
</pre></div></div>
</div>
</div>
<div class="section" id="##-mat2Vec">
<h1>## mat2Vec<a class="headerlink" href="###-mat2Vec" title="Permalink to this headline">¶</a></h1>
<p>This is a method to convert density matrix into density vector, which is used in super-operator representation for open-systems.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[14]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># create a ket state and calculate the density matrix</span>
<span class="n">denMat</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">densityMatrix</span><span class="p">(</span><span class="n">ket</span><span class="o">=</span><span class="n">qStates</span><span class="o">.</span><span class="n">basis</span><span class="p">(</span><span class="n">dimension</span><span class="o">=</span><span class="mi">2</span><span class="p">,</span> <span class="n">state</span><span class="o">=</span><span class="mi">1</span><span class="p">,</span> <span class="n">sparse</span><span class="o">=</span><span class="kc">True</span><span class="p">))</span>

<span class="c1"># convert it into density vector</span>
<span class="n">denVec</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">mat2Vec</span><span class="p">(</span><span class="n">denMat</span><span class="o">=</span><span class="n">denMat</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">denMat</span><span class="o">.</span><span class="n">A</span><span class="p">)</span>
<span class="nb">print</span><span class="p">(</span><span class="n">denVec</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[[0 0]
 [0 1]]
[[0]
 [0]
 [0]
 [1]]
</pre></div></div>
</div>
</div>
<div class="section" id="##-vec2mat">
<h1>## vec2mat<a class="headerlink" href="###-vec2mat" title="Permalink to this headline">¶</a></h1>
<p>This is a method to convert density vector into density matrix.</p>
<div class="nbinput docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[15]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span><span class="c1"># convert above density vector back into the density matrix.</span>
<span class="n">denMatConverted</span> <span class="o">=</span> <span class="n">qStates</span><span class="o">.</span><span class="n">vec2mat</span><span class="p">(</span><span class="n">vec</span><span class="o">=</span><span class="n">denVec</span><span class="p">)</span>

<span class="nb">print</span><span class="p">(</span><span class="n">denMatConverted</span><span class="p">)</span>
</pre></div>
</div>
</div>
<div class="nboutput nblast docutils container">
<div class="prompt empty docutils container">
</div>
<div class="output_area docutils container">
<div class="highlight"><pre>
[[0 0]
 [0 1]]
</pre></div></div>
</div>
<div class="nbinput nblast docutils container">
<div class="prompt highlight-none notranslate"><div class="highlight"><pre><span></span>[ ]:
</pre></div>
</div>
<div class="input_area highlight-ipython3 notranslate"><div class="highlight"><pre>
<span></span>
</pre></div>
</div>
</div>
</div>


           </div>
           
          </div>
          <footer>
  
    <div class="rst-footer-buttons" role="navigation" aria-label="footer navigation">
      
      
        <a href="Demos.html" class="btn btn-neutral float-left" title="QuantumToolbox Demos" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left"></span> Previous</a>
      
    </div>
  

  <hr/>

  <div role="contentinfo">
    <p>
        &copy; Copyright 2020, Cahit Kargi
      <span class="lastupdated">
        Last updated on 2020/05/15.
      </span>

    </p>
  </div>
  Built with <a href="http://sphinx-doc.org/">Sphinx</a> using a <a href="https://github.com/rtfd/sphinx_rtd_theme">theme</a> provided by <a href="https://readthedocs.org">Read the Docs</a>. 

</footer>

        </div>
      </div>

    </section>

  </div>
  


  <script type="text/javascript">
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script>

  
  
    
   

</body>
</html>